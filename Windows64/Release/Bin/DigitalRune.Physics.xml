<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DigitalRune.Physics</name>
    </assembly>
    <members>
        <member name="T:DigitalRune.Physics.CollisionResponseFilter">
            <summary>
            Defines whether collision response between rigid bodies is enabled or disabled.
            </summary>
            <remarks>
            <para>
            Collision response means that two bodies will not penetrate each other and bounce off of each
            other. This filter does not define whether collision detection is enabled or not. To disable
            collision detection between rigid bodies use the 
            <see cref="P:DigitalRune.Geometry.Collisions.CollisionDetection.CollisionFilter"/> of the collision detection. (The 
            <see cref="P:DigitalRune.Geometry.Collisions.CollisionDomain.CollisionDetection"/> is a property of the 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/> which is a property of the 
            <see cref="T:DigitalRune.Physics.Simulation"/>.) If the <see cref="T:DigitalRune.Physics.CollisionResponseFilter"/> returns 
            <see langword="false"/> for a pair of rigid bodies, the simulation will not create
            <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/>s and the bodies will be able to move through each other.
            </para>
            <para>
            Per default, collision response is enabled for all rigid bodies. Collision response can be 
            disabled for pairs of <see cref="T:DigitalRune.Physics.RigidBody"/>s.
            </para>
            </remarks>
        </member>
        <member name="E:DigitalRune.Physics.CollisionResponseFilter.Changed">
            <summary>
            Occurs when the filter rules have changed.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.CollisionResponseFilter.Reset">
            <summary>
            Resets this filter. Collision response will be enabled for all pairs of rigid bodies.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.CollisionResponseFilter.Set(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Boolean)">
            <summary>
            Enables or disables collision response between the given rigid bodies.
            </summary>
            <param name="bodyA">The first rigid bodies.</param>
            <param name="bodyB">The second rigid bodies.</param>
            <param name="responseEnabled">
            If set to <see langword="true"/> the collision response between <paramref name="bodyA"/> and 
            <paramref name="bodyB"/> is enabled. Use <see langword="false"/> to disable the collision
            response.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="bodyA"/> or <paramref name="bodyB"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.CollisionResponseFilter.Filter(DigitalRune.Collections.Pair{DigitalRune.Physics.RigidBody})">
            <summary>
            Returns <see langword="true"/> if collision response is enabled for the given pair.
            </summary>
            <param name="pair">The pair of rigid bodies.</param>
            <returns>
            <see langword="true"/> if collision response is enabled; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.CollisionResponseFilter.OnChanged(System.EventArgs)">
            <summary>
            Raises the <see cref="E:DigitalRune.Physics.CollisionResponseFilter.Changed"/> event.
            </summary>
            <param name="eventArgs">
            <see cref="T:System.EventArgs"/> object that provides the arguments for the event.
            </param>
            <remarks>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.CollisionResponseFilter.OnChanged(System.EventArgs)"/> in a derived
            class, be sure to call the base class's <see cref="M:DigitalRune.Physics.CollisionResponseFilter.OnChanged(System.EventArgs)"/> method so that registered
            delegates receive the event.
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.AngularLimit">
            <summary>
            Defines a constraint that restricts rotational movement. This constraint is configurable
            to create custom joints.
            </summary>
            <remarks>
            <para>
            This constraint computes the relative rotation between <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.AnchorOrientationALocal"/>
            fixed on the first body and <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.AnchorOrientationBLocal"/> fixed on the second body.
            It computes the three Euler angles for the relative orientation (see 
            <see cref="M:DigitalRune.Physics.Constraints.ConstraintHelper.GetEulerAngles(DigitalRune.Mathematics.Algebra.Matrix33F)"/>).
            </para>
            <para>
            <strong>Euler Angles:</strong>
            The Euler angles are computed for following order of rotations: The first rotation
            is about the x-axis. The second rotation is about the rotated y-axis after the first 
            rotation. The last rotation is about the final z-axis.
            </para>
            <para>
            The Euler angles are unique if the second angle is less than +/- 90°. The limits for the
            rotation angles are [-180°, 180°] for the first and the third angle. And the limit for the
            second angle is ]-90°, 90°[. Important: For <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.Minimum"/> and <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.Maximum"/> 
            these angles must be specified in radians not degrees.
            </para>
            <para>
            Each rotation of the three Euler angle rotations can be restricted using <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.Minimum"/>
            and <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.Maximum"/>. Important: The second rotation must be fixed in the range 
            ]-90°, 90°[ (otherwise a Gimbal Lock situation occurs).
            </para>
            <para>
            This constraint can be used to create custom constraints. For example using a minimum and
            maximum limits of (0, 0, 0) creates a <see cref="T:DigitalRune.Physics.Constraints.NoRotationConstraint"/>. 
            Combining the <see cref="T:DigitalRune.Physics.Constraints.AngularLimit"/> with a <see cref="T:DigitalRune.Physics.Constraints.BallJoint"/> and using a minimum 
            and maximum of (-∞, 0, 0) and (+∞, 0, 0) creates a <see cref="T:DigitalRune.Physics.Constraints.HingeJoint"/>. Combining
            the <see cref="T:DigitalRune.Physics.Constraints.AngularLimit"/> with a <see cref="T:DigitalRune.Physics.Constraints.BallJoint"/> and using a minimum and maximum 
            of (-π/4, 0, -∞) and (+π/4, 0, +∞) creates a <see cref="T:DigitalRune.Physics.Constraints.Hinge2Joint"/> where the first
            rotation axis is the limited steering axis and the third axis is the rolling axis.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.AnchorOrientationALocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.AnchorOrientationBLocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.Minimum">
            <summary>
            Gets or sets the minimum movement limit on the three constraint axes (in radians).
            </summary>
            <value>
            The minimum movement limits in radians. One element for each constraint axis.
            The default is (-∞, -∞, -∞), which means that there is no minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.Maximum">
            <summary>
            Gets or sets the maximum movement limit on the three constraint axes (in radians).
            </summary>
            <value>
            The maximum movement limits in radians. One element for each constraint axis.
            The default is (+∞, +∞, +∞), which means that there is no maximum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>
            The error reduction parameter in the range [0, 1]. One entry for each constraint axis.
            </value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>
            The softness. One element for each constraint axis. The default value is (0, 0, 0).
            </value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.Restitution">
            <summary>
            Gets or sets the coefficients of restitution.
            </summary>
            <value>The coefficients of restitution. One entry for each rotation axis.</value>
            <remarks>
            <para>
            If the bodies reach a limit (<see cref="P:DigitalRune.Physics.Constraints.AngularLimit.Minimum"/> or <see cref="P:DigitalRune.Physics.Constraints.AngularLimit.Maximum"/>), the bodies 
            will bounce back. If this property is 0, there will be no bounce. If this property is 1, 
            the whole angular velocity about the constraint axis is reflected.
            </para>
            <para>
            This vector defines the restitution for each rotation axis. The minimum and maximum limit of
            one axis use the same restitution value.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.MaxForce">
            <summary>
            Gets or sets the maximal forces for the three rotational constraints.
            </summary>
            <value>
            The maximal forces for the three rotational constraints. One entry for each rotation axis.
            The default value is (+∞, +∞, +∞).
            </value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularLimit.RelativePosition">
            <summary>
            Gets the relative rotations about the constraint axes (the three Euler angles).
            </summary>
            <value>
            The relative rotation angles about the constraint axes in radians: (Angle0, Angle1, Angle2)
            </value>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> or <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularLimit.GetLimitState(System.Int32)">
            <summary>
            Gets the state of an angular limit about a certain axis.
            </summary>
            <param name="index">
            The index of the limit axis. (0 = first rotation axis, 1 = second rotation axis, 
            2 = third rotation axis)
            </param>
            <returns>
            The limit state on the given axis.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is not in the range [0, 2].
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularLimit.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularLimit.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularLimit.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.AngularVelocityMotor">
            <summary>
            Defines a motor that controls the relative angular velocity of two constrained bodies.
            </summary>
            <remarks>
            <para>
            The motor accelerates/decelerates both bodies until the relative angular velocity of the two
            bodies a round an axis (<see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.AxisALocal"/>) fixed on the first body is equal to 
            <see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.TargetVelocity"/>. 
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.AxisALocal">
            <summary>
            Gets or sets the rotation axis that is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>. 
            </summary>
            <value>The rotation axis in local space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.</value>
            <remarks>
            <para>
            This axis is the constraint axis around which the angular velocity is controlled.
            This vector is automatically normalized if possible.
            </para>
            <para>
            If <see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.UseSingleAxisMode"/> is <see langword="true"/> and <see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.AxisALocal"/>
            is a zero vector, the motor is disabled. 
            If <see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.UseSingleAxisMode"/> is <see langword="false"/> and <see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.AxisALocal"/>
            is a zero vector, the motor is enabled and cancels all rotational velocities. 
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.TargetVelocity">
            <summary>
            Gets or sets the target angular velocity around the rotation axis (<see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.AxisALocal"/>).
            </summary>
            <value>The target angular velocity.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this motor.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that the motor can apply.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.UseSingleAxisMode">
            <summary>
            Gets or sets a value indicating whether the motor applies forces only on a single axis.
            </summary>
            <value>
            <see langword="true"/> if motor applies forces on a single axis; otherwise, 
            <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            In single-axis-mode the motor applies forces on a single constraint axis. If 
            <see cref="P:DigitalRune.Physics.Constraints.AngularVelocityMotor.UseSingleAxisMode"/> is <see langword="false"/>, the motor applies a force on 
            the same axis as in single-axis-mode but also on two orthogonal axes. In this 
            multiple-axes-mode the motor drives the bodies on the main constraint axis and cancels all 
            movements orthogonal to this axis. This multiple-axis motor is more stable but costs a bit 
            more performance.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularVelocityMotor.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularVelocityMotor.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.AngularVelocityMotor.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.BallJoint">
            <summary>
            Defines a ball-and-socked joint.
            </summary>
            <remarks>
            <para>
            This joint is known as ball joint, ball-and-socked joint or spherical joint. It removes all 3
            translational degrees of freedom and allows only rotations. The rotations are not limited.
            </para>
            <para>
            See also <see href="http://en.wikipedia.org/wiki/Ball_joint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.AnchorPositionALocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.BallJoint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.BallJoint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.BallJoint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.BallJoint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.Constraint">
            <summary>
            Defines a constraint between two rigid bodies.
            </summary>
            <remarks>
            A constraint limits the movement of two bodies relative two each other. It restricts the
            degrees of movement of one body relative to the other body.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.BodyA">
            <summary>
            Gets or sets the first body.
            </summary>
            <value>
            The first body. (Use the special <see cref="F:DigitalRune.Physics.Simulation.World"/> body to constrain
            the other body relative to world space.)
            </value>
            <remarks>
            If you want to constrain a rigid body relative to world space, use the special
            <see cref="F:DigitalRune.Physics.Simulation.World"/> as the other body of the two constraint bodies.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.BodyB">
            <summary>
            Gets or sets the second body.
            </summary>
            <value>
            The second body. (Use the special <see cref="F:DigitalRune.Physics.Simulation.World"/> body to constrain
            the other body relative to world space.)
            </value>
            <remarks>
            If you want to constrain a rigid body relative to world space, use the special
            <see cref="F:DigitalRune.Physics.Simulation.World"/> as the other body of the two constraint bodies.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.Enabled">
            <summary>
            Gets or sets a value indicating whether this constraint is enabled.
            </summary>
            <value>
            <see langword="true"/> if enabled; otherwise, <see langword="false"/>.
            The default is <see langword="true"/>.
            </value>
            <remarks>
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.Enabled"/> can be set to <see langword="false"/> to temporarily disable the
            constraint. If the constraint should be disabled for a longer period, it is more efficient
            to remove the constraint from the <see cref="P:DigitalRune.Physics.Constraints.Constraint.Simulation"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.CollisionEnabled">
            <summary>
            Gets or sets a value indicating whether collisions between <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> and
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> are disabled.
            </summary>
            <value>
            <see langword="true"/> if collisions are enabled; otherwise, <see langword="false"/>.
            The default is <see langword="true"/> (= collisions are enabled).
            </value>
            <remarks>
            <para>
            This property can be set to <see langword="false"/> to disable collision detection between
            the constraint bodies. Disabling collisions improves performance and is often necessary,
            for example, for two connected limbs in a ragdoll that are always penetrating each other.
            </para>
            <para>
            This flag can only be used if the collision detection of the <see cref="P:DigitalRune.Physics.Constraints.Constraint.Simulation"/>
            uses a collision filter that implements <see cref="T:DigitalRune.Geometry.Collisions.ICollisionFilter"/>. This is the case
            with a new <see cref="T:DigitalRune.Physics.Simulation"/> instance: By default,
            <c>Simulation.CollisionDomain.CollisionDetection.CollisionFilter</c> is set to a
            <see cref="T:DigitalRune.Geometry.Collisions.CollisionFilter"/> instance. If the <see cref="P:DigitalRune.Geometry.Collisions.CollisionDetection.CollisionFilter"/> 
            property is set to a custom filter that does not implement <see cref="T:DigitalRune.Geometry.Collisions.ICollisionFilter"/>,
            then this property does nothing.
            </para>
            <para>
            If you change the collision filtering manually by explicitly enabling/disabling collisions
            between rigid body pairs in the collision filter, then <see cref="P:DigitalRune.Physics.Constraints.Constraint.CollisionEnabled"/>
            should not be used (leave the default value of <see langword="true"/>). Otherwise, 
            the constraint might override your filter settings. To avoid conflicts, either define
            the collision filtering between body pairs manually using the collision filter or use the 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.CollisionEnabled"/> property to disable collisions.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.Simulation">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Constraint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.OnAddToSimulation">
            <summary>
            Called when this constraint is added to a simulation.
            </summary>
            <remarks>
            <para>
            The simulation to which the constraint is added is set in the property 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.Simulation"/>.
            </para>
            <para>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.Constraints.Constraint.OnAddToSimulation"/> in a 
            derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.Constraints.Constraint.OnAddToSimulation"/> method.
            </para>
            </remarks>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> or <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> is <see langword="null"/>. The constraint bodies 
            must not be <see langword="null"/> when a constraint/joint is added to a simulation.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.OnRemoveFromSimulation">
            <summary>
            Called when this constraint is removed from a simulation.
            </summary>
            <remarks>
            <para>
            The simulation from which the constraint is removed is set in the property 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.Simulation"/>. After <see cref="M:DigitalRune.Physics.Constraints.Constraint.OnRemoveFromSimulation"/> the property 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.Simulation"/> will be reset to <see langword="null"/>.
            <para>
            </para>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.Constraints.Constraint.OnRemoveFromSimulation"/>
            in a derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.Constraints.Constraint.OnRemoveFromSimulation"/>
            method.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.Setup">
            <summary>
            Called by the simulation to prepare this constraint for constraint solving for a new time
            step.
            </summary>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> or <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.OnSetup">
            <summary>
            Called when constraint should be set-up for a new time step.
            </summary>
            <remarks>
            This method is called by <see cref="M:DigitalRune.Physics.Constraints.Constraint.Setup"/>, but only if the constraint is 
            enabled and all <see cref="T:DigitalRune.Physics.Constraints.Constraint"/> properties are properly initialized.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.ApplyImpulse">
            <summary>
            Called by the simulation to apply an impulse that satisfies the constraint.
            </summary>
            <returns>
            <see langword="true"/> if a constraint larger than 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MinConstraintImpulse"/> was applied.
            </returns>
            <remarks>
            This method is called by the simulation multiple times per time step. In each time step
            <see cref="M:DigitalRune.Physics.Constraints.Constraint.Setup"/> must be called once before calling this method.
            </remarks>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            <see cref="M:DigitalRune.Physics.Constraints.Constraint.Setup"/> was not called before <see cref="M:DigitalRune.Physics.Constraints.Constraint.ApplyImpulse"/>.</exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.OnApplyImpulse">
            <summary>
            Called when the constraint impulse should be applied.
            </summary>
            <returns>
            <see langword="true"/> if a constraint larger than 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MinConstraintImpulse"/> was applied.
            </returns>
            <remarks>
            This method is called by <see cref="M:DigitalRune.Physics.Constraints.Constraint.ApplyImpulse"/> to apply an impulse that
            satisfies the constraint. This method is only called if the constraint is enabled and if all 
            <see cref="T:DigitalRune.Physics.Constraints.Constraint"/> properties are properly initialized.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint.OnChanged">
            <summary>
            Called when properties of this constraint were changed.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.ConstraintCollection">
            <summary>
            Stores the <see cref="T:DigitalRune.Physics.Constraints.Constraint"/> objects of a simulation.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.ConstraintCollection"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintCollection.InsertItem(System.Int32,DigitalRune.Physics.Constraints.Constraint)">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintCollection.SetItem(System.Int32,DigitalRune.Physics.Constraints.Constraint)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.ContactConstraint">
            <summary>
            Defines a constraint at a rigid body contact that models non-penetration, dry friction and
            bounciness.
            </summary>
            <remarks>
            <para>
            The simulation automatically creates <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/>s for all contacts that
            are found by the collision detection and where collision response is enabled.
            </para>
            <para>
            The property <see cref="T:DigitalRune.Geometry.Collisions.Contact"/>.<see cref="P:DigitalRune.Geometry.Collisions.Contact.UserData"/>
            is used by the simulation to store references to the <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> instances.
            Therefore, the <see cref="P:DigitalRune.Geometry.Collisions.Contact.UserData"/> property of contacts between 
            rigid bodies must not be changed. In other words, the relationship between contacts and
            contact constraints is:
            <code>
            myContactConstraint.Contact == myContact
            myContact.UserData == myContactConstraint
            </code>
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.BodyA">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.BodyB">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.DigitalRune#Physics#Constraints#IConstraint#Enabled">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.DigitalRune#Physics#Constraints#IConstraint#CollisionEnabled">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.Simulation">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.Contact">
            <summary>
            Gets the contact.
            </summary>
            <value>The contact.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>
            The error reduction parameter in the range [0, 1]. The default value is 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.ContactErrorReduction"/>.
            </value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint
            error, in this case rigid body interpenetration, is removed. If the error reduction
            parameter is 0, constraint errors are not removed. If the value is 1 the simulation tries to
            remove the whole constraint error in one time step - which is usually unstable. A good value
            is for example 0.3.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.RelativeVelocity">
            <summary>
            Gets the relative velocity of the contact points in world space (including surface motion).
            </summary>
            <value>The relative velocity in world space.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.RelativeNormalVelocity">
            <summary>
            Gets the relative velocity in normal direction.
            </summary>
            <value>The relative normal velocity.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.DigitalRune#Physics#Constraints#IConstraint#AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.StackingTolerance">
            <summary>
            Gets or sets the stacking tolerance.
            </summary>
            <value>The stacking tolerance.</value>
            <remarks>
            See also <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.StackingTolerance"/>. This is the basically the
            same value but is set by the constraint solver. If there a are very little objects in the
            island we do not use the stacking tolerance because it can create a torque for rolling 
            objects like spheres, cylinders and cones.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ContactConstraint.Used">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> is still in 
            used. (Used in Simulation.UpdateContacts.)
            </summary>
            <value>
            <see langword="true"/> if used; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ContactConstraint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ContactConstraint.Create(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,DigitalRune.Geometry.Collisions.Contact)">
            <summary>
            Creates an instance of the <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> class. (This method reuses a
            previously recycled instance or allocates a new instance if necessary.)
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="contact">The contact.</param>
            <returns>A new or reusable instance of the <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> class.</returns>
            <remarks>
            <para>
            This method tries to obtain a previously recycled instance from a resource pool if resource
            pooling is enabled (see <see cref="P:DigitalRune.ResourcePool.Enabled">ResourcePool.Enabled</see>). If no
            object is available, a new instance is automatically allocated on the heap. 
            </para>
            <para>
            The owner of the object should call <see cref="M:DigitalRune.Physics.Constraints.ContactConstraint.Recycle"/> when the instance is no longer 
            needed.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ContactConstraint.Recycle">
            <summary>
            Recycles this instance of the <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> class.
            </summary>
            <remarks>
            <para>
            This method resets this instance and returns it to a resource pool if resource pooling is 
            enabled (see <see cref="P:DigitalRune.ResourcePool.Enabled">ResourcePool.Enabled</see>).
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ContactConstraint.Setup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ContactConstraint.ApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.CylindricalJoint">
            <summary>
            Defines a cylindrical slider joint.
            </summary>
            <remarks>
            <para>
            This joint allows only translational movement and rotational movement along the slider axis. 
            It removes all other translational and rotational degrees of freedom. The slider axis is the
            x-axis of the constraint anchor.
            </para>
            <para>
            See also <see href="http://en.wikipedia.org/wiki/Cylindrical_joint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.AnchorPoseBLocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.LinearMinimum">
            <summary>
            Gets or sets the minimum translational movement limit on the slider axis.
            </summary>
            <value>
            The minimum translational movement limit. The default is -∞, which means that there is no 
            minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.LinearMaximum">
            <summary>
            Gets or sets the maximum translational movement limit on the slider axis.
            </summary>
            <value>
            The maximum translational movement limit. The default is +∞, which means that there is no 
            minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.AngularMinimum">
            <summary>
            Gets or sets the minimum rotation limit for rotations about the slider axis.
            </summary>
            <value>
            The minimum rotation limit. The default is -∞, which means that there is no minimum
            rotation limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.AngularMaximum">
            <summary>
            Gets or sets the minimum rotation limit for rotations about the slider axis.
            </summary>
            <value>
            The minimum rotation limit. The default is +∞, which means that there is no maximum
            rotation limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution for slider limits.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a limit on the slider axis, the bodies will bounce back. If this 
            property is 0, there will be no bounce. If this property is 1, the whole velocity on/about 
            the slider axis is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.LinearRelativePosition">
            <summary>
            Gets the relative position on the slider axis.
            </summary>
            <value>The relative position on the slider.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.CylindricalJoint.AngularRelativePosition">
            <summary>
            Gets the relative rotation about the slider axis.
            </summary>
            <value>The relative rotation about the slider.</value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.CylindricalJoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.CylindricalJoint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.CylindricalJoint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.CylindricalJoint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.CylindricalJoint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.CylindricalJoint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.CylindricalJoint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.DistanceLimit">
            <summary>
            Defines a constraint that limits the distance of two points.
            </summary>
            <remarks>
            This constraint forces the constraint anchor points on the two bodies to have a distance
            between <see cref="P:DigitalRune.Physics.Constraints.DistanceLimit.MinDistance"/> and <see cref="P:DigitalRune.Physics.Constraints.DistanceLimit.MaxDistance"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.AnchorPositionALocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.MinDistance">
            <summary>
            Gets or sets the minimal allowed distance between the constraint anchor points.
            </summary>
            <value>
            The minimal allowed distance between the constraint anchor points. The default value is 0.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.MaxDistance">
            <summary>
            Gets or sets the maximal allowed distance between the constraint anchor points.
            </summary>
            <value>
            The maximal allowed distance between the constraint anchor points. The default value is 1.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.DistanceLimit.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.DistanceLimit.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.DistanceLimit.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.DistanceLimit.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.EulerMotor">
            <summary>
            Defines a motor that controls the relative orientation of two constrained bodies using Euler
            angle.
            </summary>
            <remarks>
            <para>
            The motor pushes both bodies until the relative orientation of the constraint anchor on the
            second body relative to the constraint anchor on the first body is equal to the three Euler
            angles defined in <see cref="P:DigitalRune.Physics.Constraints.EulerMotor.TargetAngles"/>. The motor acts like a damped-spring that rotates 
            the bodies (controlled by <see cref="P:DigitalRune.Physics.Constraints.EulerMotor.SpringConstant"/> and <see cref="P:DigitalRune.Physics.Constraints.EulerMotor.DampingConstant"/>).
            The three Euler angles are defined as in the <see cref="T:DigitalRune.Physics.Constraints.AngularLimit"/>.
            </para>
            <para>
            The target orientation is defined using Euler angles. In contrast, 
            <see cref="T:DigitalRune.Physics.Constraints.QuaternionMotor"/> is a motor that controls the orientation where the target 
            orientation is defined using a <see cref="T:DigitalRune.Mathematics.Algebra.QuaternionF"/>.
            </para>
            <para>
            <strong>Euler Angles:</strong>
            The <see cref="T:DigitalRune.Physics.Constraints.EulerMotor"/> uses the same Euler angles as the <see cref="T:DigitalRune.Physics.Constraints.AngularLimit"/>.
            </para>
            <para>
            The Euler angles are computed for following order of rotations: The first rotations
            is about the x-axis. The second rotation is about the rotated y-axis after the first 
            rotation. The last rotation is about the final z-axis.
            </para>
            <para>
            The Euler angles are unique if the second angle is less than +/- 90°. The limits for the
            rotation angles are [-180°, 180°] for the first and the third angle. And the limit for the
            second angle is [-90°, 90°].
            </para>
            <para>
            Use <see cref="M:DigitalRune.Physics.Constraints.ConstraintHelper.GetEulerAngles(DigitalRune.Mathematics.Algebra.Matrix33F)"/> to get the Euler angles of a given rotation.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.AnchorOrientationALocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.AnchorOrientationBLocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.TargetAngles">
            <summary>
            Gets or sets the target angles.
            </summary>
            <value>
            The target values for the three Euler angles in radians: (angle0, angle1, angle2). an angle
            can be set to <see cref="F:System.Single.NaN"/> to disable the motor on this axis.
            </value>
            <remarks>
            <para>
            The <see cref="T:DigitalRune.Physics.Constraints.EulerMotor"/> uses the same Euler angles as the <see cref="T:DigitalRune.Physics.Constraints.AngularLimit"/>.
            </para>
            <para>
            The Euler angles are computed for following order of rotations: The first rotations
            is about the x-axis. The second rotation is about the rotated y-axis after the first 
            rotation. The last rotation is about the final z-axis.
            </para>
            <para>
            The Euler angles are unique if the second angle is less than +/- 90°. The limits for the
            rotation angles are [-180°, 180°] for the first and the third angle. And the limit for the
            second angle is [-90°, 90°].
            </para>
            <para>
            Use <see cref="M:DigitalRune.Physics.Constraints.ConstraintHelper.GetEulerAngles(DigitalRune.Mathematics.Algebra.Matrix33F)"/> to get the Euler angles of a given 
            rotation.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.SpringConstant">
            <summary>
            Gets or sets the spring constant.
            </summary>
            <value>The spring constant. The default value is 6000.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.DampingConstant">
            <summary>
            Gets or sets the damping constant.
            </summary>
            <value>The damping constant. The default value is 900.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this motor.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that the motor can apply.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.EulerMotor.MaxVelocity">
            <summary>
            Gets or sets the maximal velocity.
            </summary>
            <value>The maximal velocity. The default value is +∞.</value>
            <remarks>
            The motor will not create a velocity larger than this limit.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.EulerMotor.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.EulerMotor.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.EulerMotor.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.FixedJoint">
            <summary>
            Defines a fixed joint that removes all degrees of freedom.
            </summary>
            <remarks>
            <para>
            This joint is also known as weld joint or glue joint. This joint does not allow any relative
            motion between the two constraint bodies, as if they are glued together.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.AnchorPoseBLocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.FixedJoint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.FixedJoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.FixedJoint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.FixedJoint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.FixedJoint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.FixedJoint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.FixedJoint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.FixedJoint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.Hinge2Joint">
            <summary>
            Defines a joint that allows rotations on two axis. The joint can be used to model the front
            wheel of a car.
            </summary>
            <remarks>
            <para>
            This joint is best understood by an example: It models the front wheel of a car. The front 
            wheel rotates freely around one axis (rolling axis). It can also rotate about an axis that is 
            normal to the wheel axis (steering axis). The second rotation is controlled by the steering 
            wheel and is used to steer the car. Per convention the steering axis is the x-axis of the
            constraint anchors and the rolling axis is the z-axis. The steering and rolling angles can be 
            limited with <see cref="P:DigitalRune.Physics.Constraints.Hinge2Joint.Minimum"/> and <see cref="P:DigitalRune.Physics.Constraints.Hinge2Joint.Maximum"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.AnchorPoseBLocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.Minimum">
            <summary>
            Gets or sets the minimum rotation limits about the two rotation axis.
            </summary>
            <value>
            The minimum rotation limits in radians. The first element is the minimum angle about the
            constraint anchor x-axis. The second element is the minimum angle about the constraint
            anchor z-axis. The default is (-π / 4, -∞).
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.Maximum">
            <summary>
            Gets or sets the maximum rotation limits about the two rotation axis.
            </summary>
            <value>
            The maximum rotation limits in radians. The first element is the maximum angle about the
            constraint anchor x-axis. The second element is the maximum angle about the constraint
            anchor z-axis. The default is (+π / 4, +∞).
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a limit (see <see cref="P:DigitalRune.Physics.Constraints.Hinge2Joint.Minimum"/> or <see cref="P:DigitalRune.Physics.Constraints.Hinge2Joint.Maximum"/>), the bodies 
            will bounce back. If this property is 0, there will be no bounce. If this property is 1, the 
            whole velocity is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.Hinge2Joint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Hinge2Joint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.Hinge2Joint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Hinge2Joint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Hinge2Joint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Hinge2Joint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Hinge2Joint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Hinge2Joint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.HingeJoint">
            <summary>
            Defines a hinge joint that only allows the constraint bodies to rotate about the hinge
            axis.
            </summary>
            <remarks>
            <para>
            This joint is known as hinge joint or revolute joint. It only allows rotations around the
            hinge axis. Per convention the hinge axis is the x-axis of the constraint anchors.
            </para>
            <para>
            This joint can be used to model a hinge that connects a door to a wall. <see cref="P:DigitalRune.Physics.Constraints.HingeJoint.Minimum"/>
            and <see cref="P:DigitalRune.Physics.Constraints.HingeJoint.Maximum"/> can be used to define the allowed movement angle for the door.
            Another use of the joint is to connect a rotating wheel to a body (e.g. a car).
            </para>
            <para>
            See also <see href="http://en.wikipedia.org/wiki/Revolute_joint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.AnchorPoseBLocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.Minimum">
            <summary>
            Gets or sets the minimum rotation limit about the hinge axis in radians.
            </summary>
            <value>
            The minimum rotation limit about the hinge axis in radians. The default is -∞, which means 
            that there is no minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.Maximum">
            <summary>
            Gets or sets the maximum rotation limit about the hinge axis in radians.
            </summary>
            <value>
            The maximum rotation limit about the hinge axis in radians. The default is +∞, which means 
            that there is no maximum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution for hinge limits.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a rotation limit about the hinge axis, the bodies will bounce back. If
            this property is 0, there will be no bounce. If this property is 1, the whole velocity 
            about the hinge axis is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.RelativePosition">
            <summary>
            Gets the relative rotation angle about the hinge axis.
            </summary>
            <value>The relative rotation angle about the hinge axis.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.HingeJoint.RelativeAngularVelocity">
            <summary>
            Gets the relative angular velocity about the hinge axis.
            </summary>
            <value>The relative angular velocity about the hinge axis.</value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.HingeJoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.HingeJoint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.HingeJoint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.HingeJoint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.HingeJoint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.HingeJoint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.HingeJoint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.IConstraint">
            <summary>
            Defines a constraint between two bodies.
            </summary>
            <remarks>
            A constraint limits the movement of two bodies relative two each other. It restricts the
            degrees of movement of one body relative to the other body.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.BodyA">
            <summary>
            Gets the first body.
            </summary>
            <value>The first body.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.BodyB">
            <summary>
            Gets the second body.
            </summary>
            <value>The second body.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.Enabled">
            <summary>
            Gets a value indicating whether this constraint is enabled.
            </summary>
            <value>
            <see langword="true"/> if enabled; otherwise, <see langword="false"/>.
            The default is <see langword="true"/>.
            </value>
            <remarks>
            <see cref="P:DigitalRune.Physics.Constraints.IConstraint.Enabled"/> can be set to <see langword="false"/> to temporarily disable the
            constraint. If the constraint should be disabled for a longer period, it is more efficient
            to remove the constraint from the <see cref="P:DigitalRune.Physics.Constraints.IConstraint.Simulation"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.CollisionEnabled">
            <summary>
            Gets a value indicating whether collisions between <see cref="P:DigitalRune.Physics.Constraints.IConstraint.BodyA"/> and 
            <see cref="P:DigitalRune.Physics.Constraints.IConstraint.BodyB"/> are disabled.
            </summary>
            <value>
            <see langword="true"/> if collisions are enabled; otherwise, <see langword="false"/>.
            The default is <see langword="true"/>.
            </value>
            <remarks>
            This property can be set to <see langword="false"/> to disable collision detection between 
            the constraint bodies. Disabling collisions improves performance and is often necessary,
            for example, for two connected limbs in a ragdoll that are always penetrating each other.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.Simulation">
            <summary>
            Gets the simulation to which this constraint belongs.
            </summary>
            <value>
            The simulation. The default value is <see langword="null"/>. This property is automatically
            set when the constraint is added to a simulation.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.LinearConstraintImpulse">
            <summary>
            Gets or sets the linear constraint impulse that was applied. 
            </summary>
            <value>The linear constraint impulse in world space.</value>
            <remarks>
            <para>
            This impulse was applied in the constraint anchor on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>. An
            equivalent negative impulse was applied on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </para>
            <para>
            The constraint might also have applied an angular constraint impulse, see 
            <see cref="P:DigitalRune.Physics.Constraints.IConstraint.AngularConstraintImpulse"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.IConstraint.AngularConstraintImpulse">
            <summary>
            Gets or sets the angular constraint impulse that was applied.
            </summary>
            <value>The angular constraint impulse in world space.</value>
            <remarks>
            <para>
            This impulse was applied at the center of mass of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>. An
            equivalent negative impulse was applied at the center of mass of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </para>
            <para>
            The constraint might also have applied a linear constraint impulse, see 
            <see cref="P:DigitalRune.Physics.Constraints.IConstraint.LinearConstraintImpulse"/>.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.IConstraint.Setup">
            <summary>
            Called by the simulation to prepare this constraint for constraint solving for a new time
            step.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.IConstraint.ApplyImpulse">
            <summary>
            Called by the simulation to apply an impulse that satisfies the constraint.
            </summary>
            <returns>
            <see langword="true"/> if a constraint impulse larger than 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MinConstraintImpulse"/> was applied.
            </returns>
            <remarks>
            This method is called by the simulation multiple times per time step. In each time step
            <see cref="M:DigitalRune.Physics.Constraints.IConstraint.Setup"/> must be called once before calling this method.
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.LimitState">
            <summary>
            Describe the state of a constraint limit.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.Constraints.LimitState.Inactive">
            <summary>
            The limit is inactive. The bodies are in an allowed position.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.Constraints.LimitState.Min">
            <summary>
            The minimal limit is reached.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.Constraints.LimitState.Max">
            <summary>
            The maximal limit is reached.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.Constraints.LimitState.Locked">
            <summary>
            The constraint is locked and does not allow relative movement on this constraint axis.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.LinearLimit">
            <summary>
            Defines a constraint that restricts translational movement. This constraint is configurable
            to create custom joints.
            </summary>
            <remarks>
            <para>
            <see cref="P:DigitalRune.Physics.Constraints.LinearLimit.AnchorPoseALocal"/> defines a constraint anchor point on the first body and three
            constraint axes. The movement of <see cref="P:DigitalRune.Physics.Constraints.LinearLimit.AnchorPositionBLocal"/> on the second body is 
            restricted relative to the fixed axis on the first body.
            </para>
            <para>
            This constraint can be used to create custom constraints. For example using a minimum and
            maximum limits of (-∞, 0, 0) and (+∞, 0, 0) creates a <see cref="T:DigitalRune.Physics.Constraints.PointOnLineConstraint"/> 
            where the constraint x-axis is the line axis. Using a minimum and maximum of (-∞, -∞, 0)
            and (+∞, +∞, 0) creates a <see cref="T:DigitalRune.Physics.Constraints.PointOnPlaneConstraint"/> where the constraint x- and 
            y-axes define the plane and the plane is fixed on the first body. Using a minimum and maximum
            of (0, 0, 0) creates a <see cref="T:DigitalRune.Physics.Constraints.BallJoint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.Minimum">
            <summary>
            Gets or sets the minimum movement limit on the three constraint axes.
            </summary>
            <value>
            The minimum movement limits. One element for each constraint axis.
            The default is (-∞, -∞, -∞), which means that there is no minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.Maximum">
            <summary>
            Gets or sets the maximum movement limit on the three constraint axes.
            </summary>
            <value>
            The maximum movement limits. One element for each constraint axis.
            The default is (+∞, +∞, +∞), which means that there is no maximum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>
            The error reduction parameter in the range [0, 1]. One entry for each constraint axis.
            </value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>
            The softness. One element for each constraint axis. The default value is (0, 0, 0).
            </value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.Restitution">
            <summary>
            Gets or sets the coefficients of restitution.
            </summary>
            <value>
            The coefficients of restitution. One entry for each rotation axis.
            </value>
            <remarks>
            <para>
            If the bodies reach a limit (<see cref="P:DigitalRune.Physics.Constraints.LinearLimit.Minimum"/> or <see cref="P:DigitalRune.Physics.Constraints.LinearLimit.Maximum"/>), the bodies 
            will bounce back. If this property is 0, there will be no bounce. If this property is 1, 
            the whole linear velocity along the constraint axis is reflected.
            </para>
            <para>
            This vector defines the restitution for each linear movement axis. The minimum and maximum
            limit of one axis use the same restitution value.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.MaxForce">
            <summary>
            Gets or sets the maximal forces for the three constraint axes.
            </summary>
            <value>
            The maximal forces for the three constraint axes. One entry for each constraint axis.
            The default value is (+∞, +∞, +∞).
            </value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearLimit.RelativePosition">
            <summary>
            Gets the relative position on the constraint axes.
            </summary>
            <value>
            The relative position on the constraint axes: (RelativePositionX, RelativePositionY,
            RelativePositionZ)
            </value>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> or <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearLimit.GetLimitState(System.Int32)">
            <summary>
            Gets the state of a linear limit.
            </summary>
            <param name="index">
            The index of the limit axis. (0 = x-axis, 1 = y-axis, 2 = z-axis).
            </param>
            <returns>
            The limit state on the given axis.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is not in the range [0, 2].
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearLimit.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearLimit.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearLimit.ApplyImpulse(System.Int32)">
            <summary>
            Applies the impulse for a single constraint axis.
            </summary>
            <param name="index">The index of the constraint axis.</param>
            <returns>The applied impulse.</returns>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearLimit.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.LinearVelocityMotor">
            <summary>
            Defines a motor that controls the relative linear velocity of two constrained bodies.
            </summary>
            <remarks>
            <para>
            The motor accelerates/decelerates both bodies until the relative linear velocity of the 
            constraint anchor on the second body relative to the constraint anchor on the first body is 
            equal <see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.TargetVelocity"/>. The velocity is constrained on an axis 
            (<see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AxisALocal"/>) that is fixed on the first body.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AnchorPositionALocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space 
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AxisALocal">
            <summary>
            Gets or sets the constraint axis that is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>The constraint axis in local space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.</value>
            <remarks>
            <para>
            This axis is the constraint axis that defines the direction of the relative linear velocity.
            This vector is automatically normalized if possible.
            </para>
            <para>
            If <see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.UseSingleAxisMode"/> is <see langword="true"/> and <see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AxisALocal"/>
            is a zero vector, the motor is disabled. 
            If <see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.UseSingleAxisMode"/> is <see langword="false"/> and <see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AxisALocal"/>
            is a zero vector, the motor is enabled and cancels all rotational velocities. 
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.TargetVelocity">
            <summary>
            Gets or sets the target linear velocity in the direction of the constraint axis
            (<see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AxisALocal"/>).
            </summary>
            <value>The target linear velocity.</value>
            <remarks>
            This velocity is relative to the constraint axis fixed on the first body.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this motor.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that the motor can apply.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.UseSingleAxisMode">
            <summary>
            Gets or sets a value indicating whether the motor applies forces only on a single axis.
            </summary>
            <value>
            <see langword="true"/> if motor applies forces on a single axis; otherwise, 
            <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            In single-axis-mode the motor applies forces on a single constraint axis. If 
            <see cref="P:DigitalRune.Physics.Constraints.LinearVelocityMotor.UseSingleAxisMode"/> is <see langword="false"/>, the motor applies a force on 
            the same axis as in single-axis-mode but also on two orthogonal axes. In this 
            multiple-axes-mode the motor drives the bodies on the main constraint axis and cancels all 
            movements orthogonal to this axis. This multiple-axis motor is more stable but costs a bit 
            more performance.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearVelocityMotor.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearVelocityMotor.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.LinearVelocityMotor.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.Constraint1D">
            <summary>
            Wraps a 1-dimensional constraint (a row in the constraint solver matrix).
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.Prepare(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Initializes the 1-dimensional constraint.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.ApplyImpulse(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single)">
            <summary>
            Applies the given constraint impulse.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.ApplyCorrectionImpulse(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single)">
            <summary>
            Applies the given constraint impulse.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.GetRelativeVelocity(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody)">
            <summary>
            Gets the relative constraint velocity (ignoring error correction velocities).
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.GetRelativeCorrectionVelocity(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody)">
            <summary>
            Gets the relative constraint velocity using only the error correction velocities.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.Warmstart(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody)">
            <summary>
            Applies the current constraint impulse.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.SatisfyConstraint(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single,System.Single,System.Single)">
            <summary>
            Satisfies a general constraint.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.SatisfyInequalityConstraint(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single,System.Single)">
            <summary>
            Satisfies an inequality constraint.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.SatisfyContactConstraint(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single)">
            <summary>
            Satisfies a contact constraint.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.CorrectErrors(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single,System.Single@)">
            <summary>
            Satisfies an inequality constraint using only error correction velocities. This method
            applies a Split Impulse.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.Constraint1D.SatisfyFrictionConstraint(DigitalRune.Physics.RigidBody,DigitalRune.Physics.RigidBody,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Satisfies a friction constraint.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.ConstraintHelper">
            <summary>
            Provides constraint-related helper methods.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.ComputeErrorReduction(System.Single,System.Single,System.Single)">
            <summary>
            Computes the error reduction parameter for a given spring and damping constant.
            </summary>
            <param name="deltaTime">The time step size.</param>
            <param name="springConstant">The spring constant.</param>
            <param name="dampingConstant">The damping constant.</param>
            <returns>
            The error reduction parameter that lets the constraint behave like a damped spring with the
            given parameters.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.ComputeSoftness(System.Single,System.Single,System.Single)">
            <summary>
            Computes the softness parameter for a given spring and damping constant.
            </summary>
            <param name="deltaTime">The time step size.</param>
            <param name="springConstant">The spring constant.</param>
            <param name="dampingConstant">The damping constant.</param>
            <returns>
            The softness parameter that lets the constraint behave like a damped spring with the given
            parameters.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.ComputeSpringConstant(System.Single,System.Single,System.Single)">
            <summary>
            Computes the spring constant from error reduction and softness parameters.
            </summary>
            <param name="deltaTime">The time step size.</param>
            <param name="errorReduction">The error reduction parameter.</param>
            <param name="softness">The softness parameter.</param>
            <returns>The spring constant.</returns>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.ComputeDampingConstant(System.Single,System.Single,System.Single)">
            <summary>
            Computes the damping constant from error reduction and softness parameters.
            </summary>
            <param name="deltaTime">The time step size.</param>
            <param name="errorReduction">The error reduction parameter.</param>
            <param name="softness">The softness parameter.</param>
            <returns>The damping constant.</returns>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.ComputeKMatrix(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Computes the K matrix needed by sequential impulse-based methods.
            </summary>
            <param name="body">The body.</param>
            <param name="positionWorld">The constraint anchor position in world space.</param>
            <returns>The K matrix.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="body"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.SetVelocityOfWorldPoint(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies an impulse so that the velocity of point on the body is changed.
            </summary>
            <param name="body">The body.</param>
            <param name="positionWorld">The position on the body in world space.</param>
            <param name="velocityWorld">The target velocity of the point in world space.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="body"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintHelper.GetEulerAngles(DigitalRune.Mathematics.Algebra.Matrix33F)">
            <summary>
            Gets the Euler angles for the given rotation.
            </summary>
            <param name="rotation">The rotation.</param>
            <returns>
            A vector with the three Euler angles in radians: (angle0, angle1, angle2).
            </returns>
            <remarks>
            <para>
            The Euler angles are computed for following order of rotations: The first rotations is about
            the x-axis. The second rotation is about the rotated y-axis after the first rotation. The
            last rotation is about the final z-axis.
            </para>
            <para>
            The Euler angles are unique if the second angle is less than +/- 90°. The limits for the
            rotation angles are [-180°, 180°] for the first and the third angle. And the limit for the
            second angle is [-90°, 90°].
            </para>
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.NamespaceDoc">
            <summary>
            The <see cref="N:DigitalRune.Physics.Constraints"/> namespace provides various rigid body
            constraints (limits, motors, joints, etc.).
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.NoRotationConstraint">
            <summary>
            Defines a constraint that fixes the relative orientation of two bodies.
            </summary>
            <remarks>
            <para>
            This joint removes all 3 rotational degrees of freedom. It forces the constraint anchor
            orientations to be equal. The translational movement is not restricted and both bodies can
            rotate relative to other bodies as long as both constraint bodies perform the same rotation.
            </para>
            <para>
            On its own this constraint is not very useful, but combined with constraints that restrict
            translational movement it creates practical joints. For example, if this constraint is
            combined with a <see cref="T:DigitalRune.Physics.Constraints.PointOnLineConstraint"/>, it creates a point-on-line constraint
            with fixed relative orientations.
            </para>
            <para>
            One constraint body can be set to the simulation <see cref="F:DigitalRune.Physics.Simulation.World"/> to create a
            body that cannot rotate. But in this case it is more efficient and more stable to lock the
            rotations of the body using <see cref="T:DigitalRune.Physics.RigidBody"/> properties 
            (<see cref="P:DigitalRune.Physics.RigidBody.LockRotationX"/>, <see cref="P:DigitalRune.Physics.RigidBody.LockRotationY"/> and 
            <see cref="P:DigitalRune.Physics.RigidBody.LockRotationZ"/>).
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.AnchorOrientationALocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.AnchorOrientationBLocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.NoRotationConstraint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.NoRotationConstraint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.NoRotationConstraint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.NoRotationConstraint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.NoRotationConstraint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.NoRotationConstraint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.NoRotationConstraint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.NoRotationConstraint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.PlaneLimit">
            <summary>
            Defines a limit plane and a limit point that must stay in front of the plane.
            </summary>
            <remarks>
            <para>
            This limit places a plane on the first body. The constraint anchor point on the second body is
            forced to be in front of the plane on the other body.
            </para>
            <para>
            This constraint can be added to other joints. For example, the rotations of a 
            <see cref="T:DigitalRune.Physics.Constraints.BallJoint"/> can be limited by placing several <see cref="T:DigitalRune.Physics.Constraints.PlaneLimit"/>s.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.PlaneALocal">
            <summary>
            Gets or sets the constraint plane that this is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> 
            (defined in local space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>).
            </summary>
            <value>
            The constraint plane that this is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> (defined in local
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>).
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
            <remarks>
            This point on the second body is restricted to be in front of the plane that is fixed on
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.Restitution">
            <summary>
            Gets or sets the coefficient of restitution.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the constraint anchor point on the second body collides with the plane on the first body, 
            the bodies will bounce back. If this property is 0, there will be no bounce. If this 
            property is 1, the whole velocity is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.ConstraintImpulse">
            <summary>
            Gets or sets the constraint impulse that was applied. 
            </summary>
            <value>The constraint impulse in world space.</value>
            <remarks>
            This impulse was applied in the constraint anchor point on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in
            direction of the plane normal. An equivalent negative impulse was applied on 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PlaneLimit.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PlaneLimit.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PlaneLimit.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PlaneLimit.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.PointOnLineConstraint">
            <summary>
            Defines a constraint that forces one body to move on a line that is fixed on the other body.
            </summary>
            <remarks>
            A line axis is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>. The line goes through the point
            <see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AnchorPositionALocal"/> on the first body and the direction of the line is defined
            by <see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AxisALocal"/>. <see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AnchorPositionBLocal"/> on 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> is constrained to be on the line on the first body. This joint
            removes 2 translational degrees of movement (only relative movement on the line is allowed).
            It does not restrict rotational movement.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AxisALocal">
            <summary>
            Gets or sets the line axis that is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The line axis on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is a zero vector.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AnchorPositionALocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.Minimum">
            <summary>
            Gets or sets the minimum movement limit on the line.
            </summary>
            <value>
            The minimum movement limit. The default is -∞, which means that there is no minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.Maximum">
            <summary>
            Gets or sets the maximum movement limit on the line.
            </summary>
            <value>
            The maximum movement limit. The default is +∞, which means that there is no maximum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution for limits.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a limit on the line axis (<see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.Minimum"/> or 
            <see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.Maximum"/>), the bodies will bounce back. If this property is 0, there will be
            no bounce. If this property is 1, the whole velocity on the line axis is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>
            The maximal force. The default value is +∞.
            </value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.RelativePosition">
            <summary>
            Gets the position on the line axis relative to <see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AnchorPositionALocal"/>.
            </summary>
            <value>The position on the line axis relative to <see cref="P:DigitalRune.Physics.Constraints.PointOnLineConstraint.AnchorPositionALocal"/>.</value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnLineConstraint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.PointOnLineConstraint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnLineConstraint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnLineConstraint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnLineConstraint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnLineConstraint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnLineConstraint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.PointOnPlaneConstraint">
            <summary>
            Restricts a body to move in a plane that is fixed on another body.
            </summary>
            <remarks>
            <para>
            A plane is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>. The plane goes through
            <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AnchorPositionALocal"/> and is defined by the two axes <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.XAxisALocal"/> 
            and <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.YAxisALocal"/> that are also fixed on the first body. The point 
            <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AnchorPositionBLocal"/> on the second body can only move in this plane.
            </para>
            <para>
            This constraint removes 1 translational degree of movement (the movement normal to the plane).
            It does not restrict rotational movement.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.XAxisALocal">
            <summary>
            Gets or sets the x-axis in the plane that is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in 
            local space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The x-axis in the plane on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>. <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.XAxisALocal"/> must be perpendicular to 
            <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.YAxisALocal"/>.
            </value>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is a zero vector.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.YAxisALocal">
            <summary>
            Gets or sets the y-axis in the plane that is fixed on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in 
            local space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The y-axis in the plane on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>. <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.YAxisALocal"/> must be perpendicular to 
            <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.XAxisALocal"/>.
            </value>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is a zero vector.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AnchorPositionALocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.Minimum">
            <summary>
            Gets or sets the minimum movement limits on the plane.
            </summary>
            <value>
            The minimum movement limits on the plane. The first element is the minimum limit in the
            plane x-axis direction. The second element is the minimum in the plane y-axis direction. The
            default is (-∞, -∞), which means that there is no minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.Maximum">
            <summary>
            Gets or sets the maximum movement limits on the plane.
            </summary>
            <value>
            The maximum movement limits on the plane. The first element is the maximum limit in the
            plane x-axis direction. The second element is the maximum in the plane y-axis direction. The
            default is (+∞, +∞), which means that there is no maximum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution for limits.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a limit on the plane (<see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.Minimum"/> or <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.Maximum"/>),
            the bodies will bounce back. If this property is 0, there will be no bounce. If this
            property is 1, the whole velocity parallel to the plane is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.RelativePosition">
            <summary>
            Gets the position on the plane axes relative to <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AnchorPositionALocal"/>.
            </summary>
            <value>
            The position on the plane axes relative to <see cref="P:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.AnchorPositionALocal"/>: 
            (relativePositionX, relativePositionY).
            </value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.PointOnPlaneConstraint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PointOnPlaneConstraint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.PositionMotor">
            <summary>
            Defines a motor that controls the linear distance of two constrained bodies.
            </summary>
            <remarks>
            <para>
            The motor pushes both bodies until the relative position of the constraint anchor on the
            second body relative to the constraint anchor on the first body is equal to 
            <see cref="P:DigitalRune.Physics.Constraints.PositionMotor.TargetPosition"/>. The motor acts like a damped-spring that pushes the bodies at
            the constraint anchor points (controlled by <see cref="P:DigitalRune.Physics.Constraints.PositionMotor.SpringConstant"/> and
            <see cref="P:DigitalRune.Physics.Constraints.PositionMotor.DampingConstant"/>).
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.AnchorPositionBLocal">
            <summary>
            Gets or sets the constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space
            of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor position on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.TargetPosition">
            <summary>
            Gets or sets the target position of the <see cref="P:DigitalRune.Physics.Constraints.PositionMotor.AnchorPositionBLocal"/> relative to 
            <see cref="P:DigitalRune.Physics.Constraints.PositionMotor.AnchorPoseALocal"/>
            </summary>
            <value>The target position.</value>
            <remarks>
            This target position is the target position the constraint anchor on the second body
            relative to the constraint anchor position and constraint anchor axes on the first body.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.SpringConstant">
            <summary>
            Gets or sets the spring constant.
            </summary>
            <value>The spring constant. The default value is 6000.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.DampingConstant">
            <summary>
            Gets or sets the damping constant.
            </summary>
            <value>The damping constant. The default value is 900.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this motor.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that the motor can apply.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.RelativePosition">
            <summary>
            Gets the relative position of the constraint anchor on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>
            relative to the constraint anchor on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>The relative position.</value>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> or <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.UseSingleAxisMode">
            <summary>
            Gets or sets a value indicating whether the motor applies forces only on a single axis.
            </summary>
            <value>
            <see langword="true"/> if motor applies forces on a single axis; otherwise, 
            <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            In single-axis-mode the motor applies forces on a single constraint axis. If 
            <see cref="P:DigitalRune.Physics.Constraints.PositionMotor.UseSingleAxisMode"/> is <see langword="false"/>, the motor applies a force on 
            the same axis as in single-axis-mode but also on two orthogonal axes. In this 
            multiple-axes-mode the motor drives the bodies on the main constraint axis and cancels all 
            movements orthogonal to this axis. This multiple-axis motor is more stable but costs a bit 
            more performance.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PositionMotor.MaxVelocity">
            <summary>
            Gets or sets the maximal velocity.
            </summary>
            <value>The maximal velocity.</value>
            <remarks>
            The motor will not create a velocity larger than this limit.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PositionMotor.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PositionMotor.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PositionMotor.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.PrismaticJoint">
            <summary>
            Defines a prismatic slider joint.
            </summary>
            <remarks>
            <para>
            This joint allows only translational movement along the slider axis. It removes all other
            translational and rotational degrees of freedom. The slider axis is the x-axis of the
            constraint anchor.
            </para>
            <para>
            See also <see href="http://en.wikipedia.org/wiki/Prismatic_joint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.AnchorPoseBLocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.Minimum">
            <summary>
            Gets or sets the minimum movement limit on the slider axis.
            </summary>
            <value>
            The minimum movement limit. The default is -∞, which means that there is no minimum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.Maximum">
            <summary>
            Gets or sets the maximum movement limit on the slider axis.
            </summary>
            <value>
            The maximum movement limit. The default is +∞, which means that there is no maximum limit.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution for slider limits.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a limit on the slider axis (<see cref="P:DigitalRune.Physics.Constraints.PrismaticJoint.Minimum"/> or 
            <see cref="P:DigitalRune.Physics.Constraints.PrismaticJoint.Maximum"/>), the bodies will bounce back. If this property is 0, there will be
            no bounce. If this property is 1, the whole velocity on the slider axis is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.PrismaticJoint.RelativePosition">
            <summary>
            Gets the relative position on the slider axis.
            </summary>
            <value>The relative position on the slider.</value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PrismaticJoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.PrismaticJoint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PrismaticJoint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PrismaticJoint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PrismaticJoint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PrismaticJoint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.PrismaticJoint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.QuaternionMotor">
            <summary>
            Defines a motor that controls the relative orientation of two constrained bodies using
            quaternions.
            </summary>
            <remarks>
            <para>
            The motor pushes both bodies until the relative orientation of the constraint anchor on the
            second body relative to the constraint anchor on the first body is equal to 
            <see cref="P:DigitalRune.Physics.Constraints.QuaternionMotor.TargetOrientation"/>. The motor acts like a damped-spring that rotates the bodies
            (controlled by <see cref="P:DigitalRune.Physics.Constraints.QuaternionMotor.SpringConstant"/> and <see cref="P:DigitalRune.Physics.Constraints.QuaternionMotor.DampingConstant"/>).
            </para>
            <para>
            The target orientation is defined using a <see cref="T:DigitalRune.Mathematics.Algebra.QuaternionF"/>. In contrast, 
            <see cref="T:DigitalRune.Physics.Constraints.EulerMotor"/> is a motor that controls the orientation where the target orientation
            is defined using 3 Euler angle.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.AnchorOrientationALocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.AnchorOrientationBLocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.TargetOrientation">
            <summary>
            Gets or sets the target orientation of the anchor on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> 
            relative to the anchor on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>. 
            </summary>
            <value>The target orientation.</value>
            <remarks>
            This target orientation is the target orientation of <see cref="P:DigitalRune.Physics.Constraints.QuaternionMotor.AnchorOrientationBLocal"/>
            relative to <see cref="P:DigitalRune.Physics.Constraints.QuaternionMotor.AnchorOrientationALocal"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.SpringConstant">
            <summary>
            Gets or sets the spring constant.
            </summary>
            <value>The spring constant. The default value is 6000.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.DampingConstant">
            <summary>
            Gets or sets the damping constant.
            </summary>
            <value>The damping constant. The default value is 900.</value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this motor.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that the motor can apply.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.MaxVelocity">
            <summary>
            Gets or sets the maximal velocity.
            </summary>
            <value>The maximal velocity.</value>
            <remarks>
            The motor will not create a velocity larger than this limit.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.QuaternionMotor.UseSingleAxisMode">
            <summary>
            Gets or sets a value indicating whether the motor applies forces only on a single axis.
            </summary>
            <value>
            <see langword="true"/> if motor applies forces on a single axis; otherwise, 
            <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            In single-axis-mode the motor applies forces on a single constraint axis. If 
            <see cref="P:DigitalRune.Physics.Constraints.QuaternionMotor.UseSingleAxisMode"/> is <see langword="false"/>, the motor applies a force on 
            the same axis as in single-axis-mode but also on two orthogonal axes. In this 
            multiple-axes-mode the motor drives the bodies on the main constraint axis and cancels all 
            movements orthogonal to this axis. This multiple-axis motor is more stable but costs a bit 
            more performance.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.QuaternionMotor.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.QuaternionMotor.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.QuaternionMotor.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.ConstraintSolver">
            <summary>
            Solves constraints (joints, contacts).
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.ConstraintSolver.Simulation">
            <summary>
            Gets the simulation.
            </summary>
            <value>The simulation.</value>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintSolver.#ctor(DigitalRune.Physics.Simulation)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.ConstraintSolver"/> class.
            </summary>
            <param name="simulation">The simulation.</param>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.ConstraintSolver.Solve(DigitalRune.Physics.SimulationIsland,System.Single)">
            <summary>
            Solves all constraints of the specified island.
            </summary>
            <param name="island">The simulation island.</param>
            <param name="deltaTime">The time step size.</param>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.SequentialImpulseBasedSolver">
            <summary>
            Solves constraints using <i>Sequential Impulses</i>.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.SequentialImpulseBasedSolver.#ctor(DigitalRune.Physics.Simulation)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.SequentialImpulseBasedSolver"/> class.
            </summary>
            <param name="simulation">The simulation.</param>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.SequentialImpulseBasedSolver.Solve(DigitalRune.Physics.SimulationIsland,System.Single)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.TwistSwingLimit">
            <summary>
            Defines a twist and swing limits to limit rotations.
            </summary>
            <remarks>
            <para>
            This limit is often used to limit the rotation of ragdoll joints. 
            <see cref="P:DigitalRune.Physics.Constraints.TwistSwingLimit.AnchorOrientationALocal"/> defines a coordinate frame fixed on the first body. 
            <see cref="P:DigitalRune.Physics.Constraints.TwistSwingLimit.AnchorOrientationBLocal"/> defines a coordinate frame fixed on the second body.
            Twist is defined as the rotation of the x-axis (x is the twist axis). Swing is defined as the
            deviation of the x-axes. The y- and the z-axes fixed on the first body are the swing axes. The
            twist and swing values are angles in the range [-π, π]. Using the properties 
            <see cref="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Minimum"/> and <see cref="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Maximum"/> the twist and swing angles can be limited.
            Limiting the swing angles creates a limit cone. Different minimum and maximum swing limits can
            be chosen for the swing axes. This can be used to create a deformed limit cone. 
            </para>
            <para>
            This constraint should not be used if the swing on a swing axis is locked (minimum and maximum
            is set to 0). In this case a different constraint type should be used (e.g. a 
            <see cref="T:DigitalRune.Physics.Constraints.HingeJoint"/>). Using very non-uniform swing limits is also not recommended. The 
            swing limits appear "smoother" if the cone is symmetric.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.AnchorOrientationALocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.AnchorOrientationBLocal">
            <summary>
            Gets or sets the constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local 
            space of <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor orientation on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Minimum">
            <summary>
            Gets or sets the minimum movement limit on the twist and swing axes.
            </summary>
            <value>
            <para>
            The minimum movement limits in radians: (MinTwistAngleX, MinSwingAngleY, MinSwingAngleZ).
            The default is (0, -π/4, -π/4), which means no twist and the cone opens to -45° from the
            twist axis. The minimum limits of the swing axes must not be positive.
            </para>
            <para>The twist and swing angles are angles in the range [-π, π].</para>
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A minimum swing limit is positive.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Maximum">
            <summary>
            Gets or sets the maximum movement limit on the twist and swing axes.
            </summary>
            <value>
            <para>
            The maximum movement limits in radians: (MaxTwistAngleX, MaxSwingAngleY, MaxSwingAngleZ).
            The default is (0, π/4, π/4), which means no twist and the cone opens to +45° from the twist
            axis. The maximum limits of the swing axes must not be negative.
            </para>
            <para>
            The twist and swing angles are angles in the range [-π, π].
            </para>
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            A maximum swing limit is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1]. The default value is 0.2.</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Restitution">
            <summary>
            Gets or sets the coefficient of restitution for limits.
            </summary>
            <value>
            The coefficient of restitution for twist and swing: (TwistRestitution, SwingRestitution)
            </value>
            <remarks>
            If the bodies reach a limit on the line axis (<see cref="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Minimum"/> or 
            <see cref="P:DigitalRune.Physics.Constraints.TwistSwingLimit.Maximum"/>), the bodies will bounce back. If this property is 0, there will be no
            bounce. If this property is 1, the whole velocity is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.MaxForce">
            <summary>
            Gets or sets the maximal forces that are applied by this constraint.
            </summary>
            <value>
            The maximal forces for the twist and swing limits: (MaxForceTwist, MaxForceSwing). 
            The default value is (+∞, +∞).
            </value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.TwistSwingLimit.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.TwistSwingLimit.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.TwistSwingLimit.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.TwistSwingLimit.OnChanged">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.TwistSwingLimit.GetPointOnCone(System.Single,DigitalRune.Mathematics.Algebra.Vector3F,System.Single)">
            <summary>
            Gets a point on the swing limit cone (for debug visualization).
            </summary>
            <param name="angle">The angle about the twist axis in radians.</param>
            <param name="coneTip">The position of the tip of the cone.</param>
            <param name="distanceFromTip">The distance from tip.</param>
            <returns>
            A point that lies on the cone. The distance to the tip of the cone is 
            <paramref name="distanceFromTip"/>.
            </returns>
            <remarks>
            The swing limits form a deformed cone around the twist axis. This method can be used to get
            points to draw a debug visualization of the swing limit cone. Call this method for angles
            between 0 to 360°. Draw lines between neighbor points and the points and the cone tip. This
            creates a wire frame visualization of the swing limit cone.
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.Constraints.UniversalJoint">
            <summary>
            Defines a joint that allows rotations about two axes.
            </summary>
            <remarks>
            <para>
            A universal joint is also known as universal coupling, U joint, Cardan joint, Hardy-Spicer 
            joint or Hooke's joint. This joint fixes all three translational degrees of movement and 1
            rotational degree of movement. It allows rotations about the constraint anchor x-axis and the
            constraint anchor y-axis.
            </para>
            <para>
            See also <see href="http://en.wikipedia.org/wiki/Universal_joint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.AnchorPoseALocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyA"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.AnchorPoseBLocal">
            <summary>
            Gets or sets the constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </summary>
            <value>
            The constraint anchor pose on <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/> in local space of 
            <see cref="P:DigitalRune.Physics.Constraints.Constraint.BodyB"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.ErrorReduction">
            <summary>
            Gets or sets the error reduction parameter.
            </summary>
            <value>The error reduction parameter in the range [0, 1].</value>
            <remarks>
            The error reduction parameter is a value between 0 and 1. It defines how fast a constraint 
            error is removed. If the error reduction parameter is 0, constraint errors are not removed. 
            If the value is 1 the simulation tries to remove the whole constraint error in one time 
            step - which is usually unstable. A good value is for example 0.2.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.Softness">
            <summary>
            Gets or sets the softness.
            </summary>
            <value>The softness. The default value is 0.</value>
            <remarks>
            The softness parameter can be used to allow the constraint to be violated by a small amount.
            This has the effect that the joint appears "soft". If the value is 0 the constraint is
            "hard" and the simulation will try to counter all constraint violations. A small positive
            value (e.g. 0.001) can be used to make the constraint soft.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.Minimum">
            <summary>
            Gets or sets the minimum rotation limits about the two rotation axis.
            </summary>
            <value>
            The minimum rotation limits in radians. The first element is the minimum angle about the
            constraint anchor x-axis. The second element is the minimum angle about the constraint
            anchor y-axis. The default is (-π / 4, -π / 4).
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.Maximum">
            <summary>
            Gets or sets the maximum rotation limits about the two rotation axis.
            </summary>
            <value>
            The maximum rotation limits in radians. The first element is the maximum angle about the
            constraint anchor x-axis. The second element is the maximum angle about the constraint
            anchor y-axis. The default is (+π / 4, +π / 4).
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.Restitution">
            <summary>
            Gets or sets the coefficient of restitution.
            </summary>
            <value>The coefficient of restitution.</value>
            <remarks>
            If the bodies reach a limit (see <see cref="P:DigitalRune.Physics.Constraints.UniversalJoint.Minimum"/> or <see cref="P:DigitalRune.Physics.Constraints.UniversalJoint.Maximum"/>), the bodies 
            will bounce back. If this property is 0, there will be no bounce. If this property is 1, the 
            whole velocity is reflected.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.MaxForce">
            <summary>
            Gets or sets the maximal force that is applied by this constraint.
            </summary>
            <value>The maximal force. The default value is +∞.</value>
            <remarks>
            This property defines the maximal force that can be apply to keep the constraint satisfied. 
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.LinearConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="P:DigitalRune.Physics.Constraints.UniversalJoint.AngularConstraintImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.UniversalJoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Constraints.UniversalJoint"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.UniversalJoint.OnAddToSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.UniversalJoint.OnRemoveFromSimulation">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.UniversalJoint.OnSetup">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.UniversalJoint.OnApplyImpulse">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.Constraints.UniversalJoint.OnChanged">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.BuoyancyData">
            <summary>
            Stores the data that is needed to compute buoyancy for a single body.
            </summary>
            <remarks>
            All values are stored unscaled! The <see cref="P:DigitalRune.Geometry.IGeometricObject.Scale"/> must be applied in 
            the <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> effect.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.BuoyancyData.Mesh">
            <summary>
            Gets or sets the triangle mesh that represents the shape of the rigid body.
            </summary>
            <value>The triangle mesh of the body.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.BuoyancyData.Volume">
            <summary>
            Gets or sets the total volume of the body.
            </summary>
            <value>The volume.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.BuoyancyData.Length">
            <summary>
            Gets or sets the length of the body.
            </summary>
            <value>The length.</value>
            <remarks>
            This is simply a value that is proportional to the size of the rigid body. 
            See <see cref="M:DigitalRune.Physics.ForceEffects.Buoyancy.Prepare(DigitalRune.Physics.RigidBody)"/>.
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.Buoyancy">
            <summary>
            Applies a buoyancy force to create swimming bodies.
            </summary>
            <remarks>
            <para>
            This force field applies a buoyancy force to create the effect of rigid bodies swimming in 
            water. The force effect is applied to all bodies in the <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/>.
            Typically this will be an <see cref="T:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect"/>: A collision object models the
            area of the water, e.g. a box can be used to model a swimming pool and all bodies touching
            this box are subject to the buoyancy effect. But the area of effect does not define the 
            plane of the water surface - this is defined using the property <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.Surface"/>. 
            The area of effect could also be a <see cref="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect"/> which means that simply
            all rigid bodies in a simulation are subject to the buoyancy force. Forces are only applied
            if a part of the body is below the water surface.
            </para>
            <para>
            Since this effect uses a <see cref="T:DigitalRune.Geometry.Shapes.Plane"/> to model the water surface, it cannot be used
            to model uneven water surface (waves, waterfalls, etc.).
            </para>
            <para>
            This effects also applies a drag force (damping of movement) on the swimming bodies. The 
            strength of the damping depends on <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.LinearDrag"/> and <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.AngularDrag"/>.
            To find good values for these coefficients, you can use following approach: First, set the
            coefficients to 0 and drop an average body into the water. The body will fall into the water
            and shoot back out. Repeat the experiment with increasing <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.LinearDrag"/> values 
            until you have a good value. Then drop rotating bodies in the water and increase the 
            <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.AngularDrag"/> until rotational damping fits your needs.
            </para>
            <para>
            This force effect stores additional information in the rigid bodies. This additional 
            information is computed when a rigid body starts to touch the water. The computation of this
            information can take some time, which can be a problem if many bodies are dropped into the
            water simultaneously. To avoid this problem, the method <see cref="M:DigitalRune.Physics.ForceEffects.Buoyancy.Prepare(DigitalRune.Physics.RigidBody)"/> can be called
            to compute the additional information ahead of time (e.g. when the game level is loading).
            If there are several instances of <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> in a simulation, it is sufficient
            to call <see cref="M:DigitalRune.Physics.ForceEffects.Buoyancy.Prepare(DigitalRune.Physics.RigidBody)"/> only once per rigid body. The buoyancy information is shared
            between <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> instances.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Buoyancy.Density">
            <summary>
            Gets or sets the density of the liquid.
            </summary>
            <value>The density. The default density is <c>1000</c> (water density).</value>
            <remarks>
            Higher density values create stronger upward forces.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Buoyancy.Gravity">
            <summary>
            Gets or sets the gravity acceleration.
            </summary>
            <value>The gravity acceleration. The default value is <c>9.81</c>.</value>
            <remarks>
            The gravity acts against the normal vector direction of the <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.Surface"/>. This 
            gravity is only used to compute the magnitude of the buoyancy force. The 
            <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> does not actually pull objects "down". The <see cref="P:DigitalRune.Physics.ForceEffects.Buoyancy.Gravity"/>
            force effect is responsible for pulling objects down.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Buoyancy.Surface">
            <summary>
            Gets or sets the water surface plane (in world space).
            </summary>
            <value>
            The water surface plane (in world space). The default value is 
            <c>new Plane(Vector3F.UnitY, 0)</c>.
            </value>
            <remarks>
            <para>
            This plane defines the surface of the body of water. If a rigid body in the 
            <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> is partially or totally below this plane, the 
            buoyancy force is applied.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Buoyancy.AngularDrag">
            <summary>
            Gets or sets the angular drag coefficient.
            </summary>
            <value>The angular drag coefficient. The default value is <c>0.5</c>.</value>
            <remarks>
            The rotation of swimming rigid bodies is damped. The damping is proportional to this
            value.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Buoyancy.LinearDrag">
            <summary>
            Gets or sets the linear drag coefficient.
            </summary>
            <value>The linear drag coefficient. The default value is <c>5.0</c>.</value>
            <remarks>
            The linear movement of swimming rigid bodies is damped. The damping is proportional to this
            value.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Buoyancy.Velocity">
            <summary>
            Gets or sets the linear velocity of the water.
            </summary>
            <value>The linear water velocity. The default is a (0, 0, 0).</value>
            <remarks>
            This vector can be used to create flowing water that drags objects in the velocity
            direction.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Buoyancy.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> class.
            </summary>
            <remarks>
            The property <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> is initialized with a new instance of
            <see cref="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Buoyancy.#ctor(DigitalRune.Physics.ForceEffects.IAreaOfEffect)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> class.
            </summary>
            <param name="areaOfEffect">The area of effect.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Buoyancy.Apply(DigitalRune.Physics.RigidBody)">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Buoyancy.Prepare(DigitalRune.Physics.RigidBody)">
            <summary>
            Prepares the specified rigid body for the buoyancy effect.
            </summary>
            <param name="body">The rigid body.</param>
            <remarks>
            <para>
            This method is automatically called for each body that touches the water. It computes
            additional information per rigid body that is needed for the buoyancy effect. 
            </para>
            <para>
            To prepare the rigid bodies ahead of time, this method can be called manually - but this
            is not required. It is sufficient to call this method once per rigid body, then the body
            is prepared for all buoyancy effect instances.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="body"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.DampedSpring">
            <summary>
            Connects to rigid bodies with a damped spring.
            </summary>
            <remarks>
            A better, more stable way to model a damped spring is to use joints instead of this force
            effect. You can model damped spring by using a <see cref="T:DigitalRune.Physics.Constraints.PositionMotor"/>. Especially for
            high spring constants (stiff springs) joints are more stable.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.BodyA">
            <summary>
            Gets or sets the first rigid body.
            </summary>
            <value>The first rigid body.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.BodyB">
            <summary>
            Gets or sets the second rigid body.
            </summary>
            <value>The second rigid body.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.DampingConstant">
            <summary>
            Gets or sets the damping constant.
            </summary>
            <value>The damping constant. The default value is <c>1.6</c>.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.Length">
            <summary>
            Gets or sets the rest length of the spring.
            </summary>
            <value>The length. The default value is <c>0</c>.</value>
            <remarks>
            If the current length of the spring is equal to this value, then the spring does not apply
            forces to the attached bodies.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.AttachmentPositionALocal">
            <summary>
            Gets or sets the position where the spring is attached to the first body (in local space of
            the first body).
            </summary>
            <value>The attachment position for the first body in local space.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.AttachmentPositionBLocal">
            <summary>
            Gets or sets the position where the spring is attached to the second body (in local space of
            the second body).
            </summary>
            <value>The attachment position for the second body in local space.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.DampedSpring.SpringConstant">
            <summary>
            Gets or sets the spring constant.
            </summary>
            <value>The spring constant. The default value is <c>2.0</c>.</value>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.DampedSpring.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.DampedSpring"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.DampedSpring.OnApply">
            <summary>
            Called when the simulation wants this force effect to apply forces to rigid bodies.
            </summary>
            <remarks>
            <para>
            This method must be implemented in derived classes. This method is only called after the
            force effect was added to a simulation and <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/> was 
            called.
            </para>
            <para>
            This method is responsible for applying the forces of the effect to the rigid bodies. To
            apply a force the methods <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/>,
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> and/or
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddTorque(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/>
            base class must be used. Do not use the <strong>AddForce</strong>/<strong>AddTorque</strong>
            methods of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </para>
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.Damping">
            <summary>
            Applies a damping force (viscous drag).
            </summary>
            <remarks>
            The effect applies a force that is proportional to the current velocity of a rigid body. The
            force will slow the bodies movement.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Damping.LinearDamping">
            <summary>
            The linear damping coefficient.
            </summary>
            <value>The linear damping. The default value is <c>0.02</c>.</value>
            <remarks>
            The higher this constant is, the higher the damping force will be that damps linear
            movement.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Damping.AngularDamping">
            <summary>
            The angular damping coefficient.
            </summary>
            <value>The angular damping. The default value is <c>0.2</c>.</value>
            <remarks>
            The higher this constant is, the higher the damping force will be that damps rotational
            movement.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Damping.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Damping"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Damping"/> class.
            </summary>
            <remarks>
            The property <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> is initialized with a new instance of
            <see cref="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Damping.#ctor(DigitalRune.Physics.ForceEffects.IAreaOfEffect)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Damping"/> class.
            </summary>
            <param name="areaOfEffect">The area of effect.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Damping.Apply(DigitalRune.Physics.RigidBody)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.Explosion">
            <summary>
            Applies an explosion force for a short duration.
            </summary>
            <remarks>
            <para>
            The explosion starts immediately after it is added to a <see cref="T:DigitalRune.Physics.Simulation"/>. When the
            effect has ended (see <see cref="P:DigitalRune.Physics.ForceEffects.Explosion.Duration"/>) it removes itself automatically from the 
            <see cref="P:DigitalRune.Physics.Simulation.ForceEffects"/> collection of the <see cref="T:DigitalRune.Physics.Simulation"/>.
            </para> 
            <para>
            <strong>Explosion Model:</strong>
            The effect applies a force that pushes rigid bodies away from the center of the explosion 
            (see <see cref="P:DigitalRune.Physics.ForceEffects.Explosion.Position"/>). The effect is only applied to the rigid body's center of mass -
            size, shape and orientation of the rigid body is ignored. The force effect has a linear 
            falloff, i.e. a rigid body in <i>n</i> units distance experiences only 1/<i>n</i> of the 
            force.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Explosion.Duration">
            <summary>
            Gets or sets the duration of the explosion.
            </summary>
            <value>The duration of the explosion. The default is 0.03 s.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Explosion.EndTime">
            <summary>
            Gets or sets the simulation time when the effect ends.
            </summary>
            <value>The end time.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Explosion.Force">
            <summary>
            Gets or sets the force magnitude of the explosion.
            </summary>
            <value>The force. The default is <c>100000</c>.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Explosion.Position">
            <summary>
            Gets or sets the position of the center of the explosion.
            </summary>
            <value>The position of the explosion center. The default is <c>(0, 0, 0)</c>.</value>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Explosion.Radius">
            <summary>
            Gets or sets the explosion radius.
            </summary>
            <value>The explosion radius. The default value is 5.</value>
            <remarks>
            The explosion force will fall off from the explosion center (<see cref="P:DigitalRune.Physics.ForceEffects.Explosion.Position"/>) to this 
            radius where it reaches 0. Bodies outside this radius are not affected.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Explosion.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Explosion"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Explosion"/> class.
            </summary>
            <remarks>
            The property <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> is initialized with a new instance of
            <see cref="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Explosion.#ctor(DigitalRune.Physics.ForceEffects.IAreaOfEffect)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Explosion"/> class.
            </summary>
            <param name="areaOfEffect">The area of effect.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Explosion.OnAddToSimulation">
            <summary>
            Called when this force effect is added to a simulation.
            </summary>
            <remarks>
            The simulation to which the force effect is added is set in the property
            <see cref="T:DigitalRune.Physics.Simulation"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Explosion.OnApply">
            <summary>
            Called when the simulation wants this force effect to apply forces to rigid bodies.
            </summary>
            <remarks>
            <para>
            <strong>Notes to Inheritors:</strong>
            This method must be implemented in derived classes. This method is only called after the
            force effect was added to a simulation and <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/> was
            called.
            </para>
            <para>
            This method uses the <see cref="T:DigitalRune.Physics.ForceEffects.IAreaOfEffect"/> to call <see cref="M:DigitalRune.Physics.ForceEffects.Explosion.Apply(DigitalRune.Physics.RigidBody)"/> for each rigid
            body in the area of effect.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Explosion.Apply(DigitalRune.Physics.RigidBody)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.ForceEffect">
            <summary>
            Applies a force onto rigid bodies.
            </summary>
            <remarks>
            <para>
            If a force effect is added to a <see cref="T:DigitalRune.Physics.Simulation"/> (see 
            <see cref="P:DigitalRune.Physics.Simulation.ForceEffects"/>), it will be called during a simulation time
            step to apply forces to the rigid bodies of the simulation.
            </para>
            <para>
            <strong>Self-Removal:</strong> It is allowed that a force effect instance removes itself at
            any time from the <see cref="T:DigitalRune.Physics.Simulation"/>. This can be used to create one-shot
            effects - a force effect that applies forces and automatically removes itself from the
            simulation in <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/>.
            </para>
            <para>
            <strong>Order of events:</strong> The force effect has three special On<i>Xxx</i> methods that
            will be used in this order:
            <list type="table">
            <item>
            <term><see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/></term>
            <description>
            Is called when the force effect instance was added to the 
            <see cref="P:DigitalRune.Physics.Simulation.ForceEffects"/> collection of a 
            <see cref="T:DigitalRune.Physics.Simulation"/>. Before this method is called, the property 
            <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/> is <see langword="null"/>. When this method is called, the property
            <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/> is set to the simulation.
            </description>
            </item>
            <item>
            <term><see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/></term>
            <description>
            Is called when the simulation wants the force effect to apply its forces to the rigid bodies.
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/> can be called after <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/>, but never before.
            The property <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/> is always initialized when <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/> is
            called. <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/> is only called if the force effect is <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Enabled"/>.
            </description>
            </item>
            <item>
            <term><see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnRemoveFromSimulation"/></term>
            <description>
            Is called before the force effect instance is removed from the 
            <see cref="P:DigitalRune.Physics.Simulation.ForceEffects"/> collection of <see cref="T:DigitalRune.Physics.Simulation"/>.
            When this method is called, the property <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/> is still set. After 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnRemoveFromSimulation"/> the property <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/> is 
            <see langword="null"/>. <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/> can only be called between 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/> and <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnRemoveFromSimulation"/>.
            </description>
            </item>
            </list>
            </para>
            <para>
            <strong>Applying Forces:</strong> A <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> must not call 
            <see cref="T:DigitalRune.Physics.RigidBody"/>.<see cref="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F)"/> or other force related
            methods of the <see cref="T:DigitalRune.Physics.RigidBody"/> directly. Those methods are reserved for the user. The
            reason is: If a user applies a force with 
            <see cref="T:DigitalRune.Physics.RigidBody"/>.<see cref="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F)"/>, the added force is 
            constant for the whole duration of 
            <see cref="T:DigitalRune.Physics.Simulation"/>.<see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/>. If the 
            simulation divides one call to <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> in several 
            sub time steps, the same user force is applied in all sub time steps. But force effects are 
            called by the simulation in each sub time step. They can set a different force in each sub 
            time step. Therefore, force effects must use a different set of methods and these methods are 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/>, 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> and <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddTorque(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> 
            of this class. 
            </para>
            <para>
            To sum up: <i>Classes derived from <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> must use the 
            <strong>AddForce</strong>/<strong>AddTorque</strong> methods of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> 
            base class to apply forces to rigid bodies.</i>
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation">
            <summary>
            Gets the simulation to which this force effect belongs.
            </summary>
            <value>The simulation.</value>
            <remarks>
            This method is <see langword="null"/> before <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/> and after
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnRemoveFromSimulation"/>. Between these method calls this property is set to 
            the simulation that owns this force effect.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.ForceEffect.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> is enabled.
            </summary>
            <value>
            <see langword="true"/> if enabled; otherwise, <see langword="false"/>.
            The default is <see langword="true"/>.
            </value>
            <remarks>
            If this property is <see langword="false"/>, the force effect does not apply any
            forces. <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply"/> is only called if this property is <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.Apply">
            <summary>
            Applies forces to the rigid bodies.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnApply">
            <summary>
            Called when the simulation wants this force effect to apply forces to rigid bodies.
            </summary>
            <remarks>
            <para>
            <strong>Notes to Inheritors:</strong>
            This method must be implemented in derived classes. This method is only called after the
            force effect was added to a simulation and <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/> was called. 
            </para>
            <para>
            This method is responsible for applying the forces of the effect to the rigid bodies. To
            apply a force the methods <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/>, 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> and/or 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddTorque(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> 
            base class must be used. Do not use the <strong>AddForce</strong>/<strong>AddTorque</strong> 
            methods of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnEnabled">
            <summary>
            Called when this force effect was enabled.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnDisabled">
            <summary>
            Called when this force effect was disabled.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation">
            <summary>
            Called when this force effect is added to a simulation.
            </summary>
            <remarks>
            The simulation to which the force effect is added is set in the property 
            <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnRemoveFromSimulation">
            <summary>
            Called when this force effect is removed from a simulation.
            </summary>
            <remarks>
            The simulation from which the force effect is removed is set in the property 
            <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/>. After <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnRemoveFromSimulation"/> the property 
            <see cref="P:DigitalRune.Physics.ForceEffects.ForceEffect.Simulation"/> will be reset to <see langword="null"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a force to the rigid body.
            </summary>
            <param name="body">The rigid body.</param>
            <param name="forceWorld">The force in world space.</param>
            <param name="positionWorld">
            The world space position where the force is a applied on the body.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a force to the rigid body at the center of mass.
            </summary>
            <param name="body">The rigid body.</param>
            <param name="forceWorld">The force in world space.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddTorque(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a torque to the rigid body at the center of mass.
            </summary>
            <param name="body">The rigid body.</param>
            <param name="torqueWorld">The torque in world space.</param>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.ForceEffectCollection">
            <summary>
            Stores the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/>s of a simulation.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffectCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffectCollection"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffectCollection.InsertItem(System.Int32,DigitalRune.Physics.ForceEffects.ForceEffect)">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceEffectCollection.SetItem(System.Int32,DigitalRune.Physics.ForceEffects.ForceEffect)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.ForceField">
            <summary>
            Applies a force effect to all bodies in the <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> individually.
            </summary>
            <remarks>
            <para>
            A force field is a specialized force effect that applies a force to all bodies that are in
            the <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/>. The area of effect can be defined using collision detection,
            simple lists, or other means. Each body in the area of effect is treated individually.
            </para>
            <para>
            Derived classes must implement the method <see cref="M:DigitalRune.Physics.ForceEffects.ForceField.Apply(DigitalRune.Physics.RigidBody)"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect">
            <summary>
            Gets or sets the area of effect.
            </summary>
            <value>The area of effect. (Can be <see langword="null"/>.)</value>
            <remarks>
            The <see cref="T:DigitalRune.Physics.ForceEffects.IAreaOfEffect"/> object defines on which object the force field effect is
            applied. When the property is <see langword="null"/>, nothing is affected by the force 
            effect.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceField.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceField"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceField"/> class.
            </summary>
            <remarks>
            The property <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> is initialized with a new instance of
            <see cref="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceField.#ctor(DigitalRune.Physics.ForceEffects.IAreaOfEffect)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceField"/> class.
            </summary>
            <param name="areaOfEffect">The area of effect.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceField.OnApply">
            <summary>
            Called when the simulation wants this force effect to apply forces to rigid bodies.
            </summary>
            <remarks>
            <para>
            <strong>Notes to Inheritors:</strong>
            This method must be implemented in derived classes. This method is only called after the
            force effect was added to a simulation and <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.OnAddToSimulation"/> was 
            called.
            </para>
            <para>
            This method uses the <see cref="T:DigitalRune.Physics.ForceEffects.IAreaOfEffect"/> to call <see cref="M:DigitalRune.Physics.ForceEffects.ForceField.Apply(DigitalRune.Physics.RigidBody)"/> for each rigid 
            body in the area of effect.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ForceField.Apply(DigitalRune.Physics.RigidBody)">
            <summary>
            Applies the force effect to the specified body.
            </summary>
            <param name="body">The rigid body.</param>
            <remarks>
            <para>
            <strong>Notes to Inheritors:</strong> This method is responsible for applying the forces of
            the effect to a rigid body. To apply a force the methods 
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/>,
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddForce(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> and/or
            <see cref="M:DigitalRune.Physics.ForceEffects.ForceEffect.AddTorque(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F)"/> of the <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/>
            base class must be used. Do not use the <strong>AddForce</strong>/<strong>AddTorque</strong>
            methods of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="body"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect">
            <summary>
            Applies a force field effect to all rigid bodies that touch a certain 
            <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/>.
            </summary>
            <remarks>
            <para>
            This <see cref="T:DigitalRune.Physics.ForceEffects.IAreaOfEffect"/> uses the collision detection to define which objects are in
            the area of effect. Per default no <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/> is set, which means that no
            objects are in the area of effect. A <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/> must be created by the user
            and set in the property <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/>. The properties of the collision object
            must be set appropriately and the collision object must be added to the 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/> of the <see cref="T:DigitalRune.Physics.Simulation"/> by the user.
            </para>
            <para>
            <strong>Performance Tip:</strong> If the <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/> is not used for other 
            purposes it is good for performance if the 
            <see cref="P:DigitalRune.Geometry.Collisions.CollisionObject.Type"/> is set to 
            <see cref="F:DigitalRune.Geometry.Collisions.CollisionObjectType.Trigger"/>.
            </para>
            <para>
            <strong>Collision Filtering:</strong> As with all other collision objects the standard
            collision filtering (see <see cref="P:DigitalRune.Geometry.Collisions.CollisionDetection.CollisionFilter"/>) can be used to 
            define which objects can collide with the <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject">
            <summary>
            Gets or sets the collision object that defines the area of effect.
            </summary>
            <value>The collision object. The default is <see langword="null"/>.</value>
            <remarks>
            <para>
            This <see cref="T:DigitalRune.Physics.ForceEffects.IAreaOfEffect"/> uses the collision detection to define which objects are
            in the area of effect. Per default no <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/> is set, which means
            that no objects are in the area of effect. A <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/> must be created
            by the user and set in the property <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/>. The properties of the
            collision object must be set appropriately and the collision object must be added to the 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/> of the <see cref="T:DigitalRune.Physics.Simulation"/> by the user.
            </para>
            <para>
            <strong>Performance Tip:</strong> If the <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/> is not used for other 
            purposes it is good for performance if the 
            <see cref="P:DigitalRune.Geometry.Collisions.CollisionObject.Type"/> is set to 
            <see cref="F:DigitalRune.Geometry.Collisions.CollisionObjectType.Trigger"/>.
            </para>
            <para>
            <strong>Collision Filtering:</strong> As with all other collision objects the standard
            collision filtering (see <see cref="P:DigitalRune.Geometry.Collisions.CollisionDetection.CollisionFilter"/>) can be used to 
            define which objects can collide with the <see cref="P:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.CollisionObject"/>.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.#ctor(DigitalRune.Geometry.Collisions.CollisionObject)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect"/> class.
            </summary>
            <param name="collisionObject">The collision object.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.GeometricAreaOfEffect.Apply(DigitalRune.Physics.ForceEffects.ForceField)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect">
            <summary>
            Applies a force field effect to all <see cref="P:DigitalRune.Physics.Simulation.RigidBodies"/> of the 
            <see cref="T:DigitalRune.Physics.Simulation"/>. (An optional predicate can be used to exclude certain objects.)
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect.Exclude">
            <summary>
            Gets or sets the predicate that can be used to exclude rigid bodies from the area of effect.
            </summary>
            <value>
            The predicate that determines whether a rigid body is excluded from the area of effect. The 
            default value is <see langword="null"/>.
            </value>
            <remarks>
            If this predicate is <see langword="null"/>, all rigid bodies of the simulation are in the
            area of effect.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect.Apply(DigitalRune.Physics.ForceEffects.ForceField)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.Gravity">
            <summary>
            Applies a gravity force to rigid bodies.
            </summary>
            <remarks>
            Gravity pulls all bodies into a predefined direction, which is usually "down".
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.Gravity.Acceleration">
            <summary>
            Gets or sets the gravity acceleration vector.
            </summary>
            <value>The acceleration vector. The default value is <c>(0, -9.81, 0)</c>.</value>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Gravity.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Gravity"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Gravity"/> class.
            </summary>
            <remarks>
            The property <see cref="P:DigitalRune.Physics.ForceEffects.ForceField.AreaOfEffect"/> is initialized with a new instance of
            <see cref="T:DigitalRune.Physics.ForceEffects.GlobalAreaOfEffect"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Gravity.#ctor(DigitalRune.Physics.ForceEffects.IAreaOfEffect)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.Gravity"/> class.
            </summary>
            <param name="areaOfEffect">The area of effect.</param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.Gravity.Apply(DigitalRune.Physics.RigidBody)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.IAreaOfEffect">
            <summary>
            Defines the area of effect of a <see cref="T:DigitalRune.Physics.ForceEffects.ForceField"/>. Only rigid bodies in the area of
            effect are subject to forces.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.IAreaOfEffect.Apply(DigitalRune.Physics.ForceEffects.ForceField)">
            <summary>
            Calls <see cref="M:DigitalRune.Physics.ForceEffects.ForceField.Apply(DigitalRune.Physics.RigidBody)"/> of the given force field for all objects
            in the area of effect.
            </summary>
            <param name="forceField">The force field.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="forceField"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.ListAreaOfEffect">
            <summary>
            Applies a force field effect to all objects in a given list.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.ForceEffects.ListAreaOfEffect.RigidBodies">
            <summary>
            Gets or sets the list of rigid bodies that are affected by the force effect.
            </summary>
            <value>
            The rigid bodies in the area of effect. The default value is an empty 
            <see cref="T:System.Collections.Generic.List`1"/>.
            </value>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ListAreaOfEffect.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ListAreaOfEffect"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ListAreaOfEffect"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ListAreaOfEffect.#ctor(System.Collections.Generic.IList{DigitalRune.Physics.RigidBody})">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.ForceEffects.ListAreaOfEffect"/> class.
            </summary>
            <param name="rigidBodies">
            The list of rigid bodies. The property <see cref="P:DigitalRune.Physics.ForceEffects.ListAreaOfEffect.RigidBodies"/> is set to this list. 
            The list is not copied.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.ForceEffects.ListAreaOfEffect.Apply(DigitalRune.Physics.ForceEffects.ForceField)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.ForceEffects.NamespaceDoc">
            <summary>
            The <see cref="N:DigitalRune.Physics.ForceEffects"/> namespace provides force effects that
            apply forces in a physics simulation.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.SimulationIsland">
            <summary>
            Describes a collection of rigid bodies and constraints that can be simulated independently.
            </summary>
            <remarks>
            <para>
            In general, it is not needed to deal with simulation islands directly and users can safely
            ignore this simulation detail.
            </para>
            <para>
            In each frame the simulation creates different batches of bodies and constraints that can
            be simulated independently. Such a batch is called simulation island. If rigid bodies can
            influence each other via constraints (contacts or joints), they are sorted into the same 
            island.
            </para>
            <para>
            <strong>Sleeping:</strong> Islands can only sleep as a whole. It is not possible that some
            bodies in an island are sleeping and others are awake. If one object is awake all objects are
            awake because the movement of the awake body can propagate to the other bodies. In 
            unfortunate configurations a jittering body can keep a whole island awake. 
            </para>
            <para>
            <strong>Static and Kinematic Bodies:</strong> <see cref="F:DigitalRune.Physics.MotionType.Static"/> or 
            <see cref="F:DigitalRune.Physics.MotionType.Kinematic"/> rigid bodies are not managed in islands. They are
            not part of another island and they are not in their own island. Islands do only contain
            <see cref="F:DigitalRune.Physics.MotionType.Dynamic"/> rigid bodies. (But constraints between dynamic and 
            non-dynamic bodies are managed in the islands.)
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.Simulation">
            <summary>
            Gets or sets the simulation.
            </summary>
            <value>The simulation.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.Constraints">
            <summary>
            Gets the constraints of this island.
            </summary>
            <value>The constraints of this island.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.ContactConstraints">
            <summary>
            Gets the contact constraints of this island.
            </summary>
            <value>The contacts constraints of this island.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.RigidBodies">
            <summary>
            Gets the rigid bodies of this island.
            </summary>
            <value>The rigid bodies of this island.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.ConstraintsInternal">
            <summary>
            Gets the constraints of this island. (For internal use only.)
            </summary>
            <value>The constraints.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.ContactConstraintsInternal">
            <summary>
            Gets the contact constraints of this island. (For internal use only.)
            </summary>
            <value>The contact constraints.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.RigidBodiesInternal">
            <summary>
            Gets the rigid bodies of this island. (For internal use only.)
            </summary>
            <value>The rigid bodies.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIsland.Random">
            <summary>
            Gets or sets the random generator for constraint randomization.
            </summary>
            <value>The random generator for constraint randomization.</value>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIsland.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:DigitalRune.Physics.SimulationIsland"/> class from being created.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIsland.Create">
            <summary>
            Creates an instance of the <see cref="T:DigitalRune.Physics.SimulationIsland"/> class. (This method 
            reuses a previously recycled instance or allocates a new instance if necessary.)
            </summary>
            <returns>
            A new or reusable instance of the <see cref="T:DigitalRune.Physics.SimulationIsland"/> class.
            </returns>
            <remarks>
            <para>
            This method tries to obtain a previously recycled instance from a resource pool if resource
            pooling is enabled (see <see cref="P:DigitalRune.ResourcePool.Enabled">ResourcePool.Enabled</see>). If no
            object is available, a new instance is automatically allocated on the heap. 
            </para>
            <para>
            The owner of the object should call <see cref="M:DigitalRune.Physics.SimulationIsland.Recycle"/> when the instance is no longer 
            needed.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIsland.Recycle">
            <summary>
            Recycles this instance of the <see cref="T:DigitalRune.Physics.SimulationIsland"/> class.
            </summary>
            <remarks>
            <para>
            This method resets this instance and returns it to a resource pool if resource pooling is 
            enabled (see <see cref="P:DigitalRune.ResourcePool.Enabled">ResourcePool.Enabled</see>).
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIsland.Clear">
            <summary>
            Resets this simulation island.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIsland.IsSleeping">
            <summary>
            Controls island sleeping and returns whether this island is sleeping.
            </summary>
            <returns>
            <see langword="true"/> if all bodies are sleeping; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.SimulationIslandManager">
            <summary>
            Manages <see cref="T:DigitalRune.Physics.SimulationIsland"/>s of a <see cref="T:DigitalRune.Physics.Simulation"/>.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIslandManager.Islands">
            <summary>
            Gets the simulation islands.
            </summary>
            <value>The simulation islands.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIslandManager.IslandsInternal">
            <summary>
            Gets the simulation islands. (For internal use only.)
            </summary>
            <value>The simulation islands.</value>
        </member>
        <member name="P:DigitalRune.Physics.SimulationIslandManager.ContactSetLinks">
            <summary>
            Gets or sets the island links that are created by contact sets.
            </summary>
            <value>The contact set links.</value>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIslandManager.#ctor(DigitalRune.Physics.Simulation)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.SimulationIslandManager"/> class.
            </summary>
            <param name="simulation">The simulation.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="simulation"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIslandManager.Update">
            <summary>
            Updates the <see cref="P:DigitalRune.Physics.SimulationIslandManager.Islands"/> list and the <see cref="P:DigitalRune.Physics.RigidBody.IslandId"/> in the rigid 
            bodies.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIslandManager.GetIslandId(DigitalRune.Physics.Constraints.IConstraint)">
            <summary>
            Gets the island id of a constraint
            </summary>
            <param name="constraint">The constraint.</param>
            <returns>
            The island ID of a dynamic body of the constraint.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.SimulationIslandManager.System#Collections#Generic#IComparer{DigitalRune#Physics#SimulationIsland}#Compare(DigitalRune.Physics.SimulationIsland,DigitalRune.Physics.SimulationIsland)">
            <summary>
            Compares two islands by size.
            </summary>
            <param name="first">The first island.</param>
            <param name="second">The second island.</param>
            <returns>
            A signed integer that indicates the relative size of the simulation islands, as shown in the following table.
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>Less than zero</term>
            <description>The first island is bigger than the second island.</description>
            </item>
            <item>
            <term>Zero</term>
            <description>The first and the second island are equal in size.</description>
            </item>
            <item>
            <term>Greater than zero</term>
            <description>The second island is bigger than the first.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.UnionElement">
            <summary>
            Describes one element in the <see cref="T:DigitalRune.Physics.UnionFinder"/>.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.UnionFinder">
            <summary>
            Implements Weighted Quick Union with Path Compression - an optimal algorithm for finding 
            connected parts.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.UnionFinder.Elements">
            <summary>
            Gets the elements.
            </summary>
            <value>The elements.</value>
        </member>
        <member name="P:DigitalRune.Physics.UnionFinder.NumberOfUnions">
            <summary>
            Gets the number of unions.
            </summary>
            <value>The number of unions.</value>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.UnionFinder"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.Reset(System.Int32)">
            <summary>
            Resets the union finder.
            </summary>
            <param name="numberOfElements">
            The number of elements that should be in the <see cref="P:DigitalRune.Physics.UnionFinder.Elements"/> list.
            </param>
            <remarks>
            This method fills the <see cref="P:DigitalRune.Physics.UnionFinder.Elements"/> list with <paramref name="numberOfElements"/>
            elements. The element IDs are identical to their index in the <see cref="P:DigitalRune.Physics.UnionFinder.Elements"/> list.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.AreUnited(System.Int32,System.Int32)">
            <summary>
            Checks whether two elements belong to the same union.
            </summary>
            <param name="p">The index of the first element.</param>
            <param name="q">The index of the second element..</param>
            <returns>
            <see langword="true"/> if <paramref name="p"/> and <paramref name="q"/> belong to the same
            union; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.Compare(DigitalRune.Physics.UnionElement,DigitalRune.Physics.UnionElement)">
            <summary>
            Compares the specified <see cref="T:DigitalRune.Physics.UnionElement"/>s.
            </summary>
            <param name="elementA">The first element.</param>
            <param name="elementB">The second element.</param>
            <returns>
            +1 if the ID of <paramref name="elementA"/> is greater than the ID of
            <paramref name="elementB"/>. -1 if the ID of <paramref name="elementA"/>
            is less than the ID of <paramref name="elementB"/>. Otherwise, 0
            is returned.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.FindUnion(System.Int32)">
            <summary>
            Gets the number of the union of the given element.
            </summary>
            <param name="p">The index of the element.</param>
            <returns>The union number of the element.</returns>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.GetUnionSize(System.Int32)">
            <summary>
            Gets the size of the union that contains the given element.
            </summary>
            <param name="p">The index of the element.</param>
            <returns>
            The number of elements that are in the same union as the given element.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.UnionFinder.Unite(System.Int32,System.Int32)">
            <summary>
            Merges the unions of the two given elements.
            </summary>
            <param name="p">The index of the first element.</param>
            <param name="q">The index of the second element.</param>
        </member>
        <member name="T:DigitalRune.Physics.MassFrame">
            <summary>
            Defines the mass properties of a rigid body.
            </summary>
            <remarks>
            <para>
            <strong>A simplified explanation of mass: </strong>
            <see cref="P:DigitalRune.Physics.MassFrame.Mass"/> defines how difficult it is to change the linear velocity of a body. For
            example, if mass is infinite it is impossible to move a resting body or to stop a body that is
            already in motion. The <see cref="P:DigitalRune.Physics.MassFrame.Inertia"/> matrix is the rotational equivalent of 
            <see cref="P:DigitalRune.Physics.MassFrame.Mass"/>. It defines how difficult it is to change the angular velocity of a body.
            </para>
            <para>
            <strong>Center of Mass:</strong> For the simulation the center of mass is the center of a 
            rigid body. The center of mass has a special importance because if forces act on an 
            unconstrained rigid body (e.g. a body floating in space) any rotations will be around the 
            center of mass. In contrast, the local space origin of a rigid body can be anywhere where the
            user wants it to be. For example, the origin of rigid body with a <see cref="T:DigitalRune.Geometry.Shapes.ConeShape"/> is
            at the base of the cone whereas the center of mass of a cone is inside the cone. Or the origin
            of a human can be at the feet and the center of mass is above the pelvis area. This allows
            easy placement of the rigid body in a game editor. <see cref="P:DigitalRune.Physics.MassFrame.Pose"/>. 
            <see cref="F:DigitalRune.Geometry.Pose.Position"/> defines the position of the center of mass relative to
            the local space of the rigid body.
            </para>
            <para>
            <strong>Inertia Tensor:</strong> The inertia tensor describes the "rotational mass" of a 
            rigid body. In general, the inertia tensor is 3 x 3 matrix. But for all rigid bodies a rotated
            coordinate space can be found where all off-diagonal elements of the inertia matrix are 0. The
            axes of this rotated coordinate space are called the "principal axes". <see cref="P:DigitalRune.Physics.MassFrame.Inertia"/>
            stores the diagonal elements of the diagonalized inertia matrix. And 
            <see cref="P:DigitalRune.Physics.MassFrame.Pose"/>.<see cref="F:DigitalRune.Geometry.Pose.Orientation"/> stores the orientation of the 
            principal axis space relative to the local space of the rigid body.
            </para>
            <para>
            <strong>Pose:</strong> As described above, <see cref="P:DigitalRune.Physics.MassFrame.Pose"/> stores the position of the
            center of mass and the orientation of the coordinate space where the inertia tensor is a
            diagonal matrix. In other words, the pose describe the transformation from a space, where the
            center of mass is at the origin and the inertia matrix is a diagonal matrix, to the local
            space of the body. In other words, the pose position is equal to the center of mass and the
            columns of the pose orientation are the principal axes.
            </para>
            <para>
            <strong>Creating new <see cref="T:DigitalRune.Physics.MassFrame"/> instances:</strong> You can define 
            <see cref="P:DigitalRune.Physics.MassFrame.Mass"/>, <see cref="P:DigitalRune.Physics.MassFrame.Inertia"/> and <see cref="P:DigitalRune.Physics.MassFrame.Pose"/> manually but this is 
            non-trivial for complex shapes. Therefore, is much simpler to use 
            <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/> or <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndMass(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/> to create a 
            <see cref="T:DigitalRune.Physics.MassFrame"/> instance. The first method takes a shape and a density and computes 
            the mass properties. The second method takes a shape and a target mass value and computes mass
            frame properties so that the mass is equal to the target mass.
            </para>
            <para>
            <strong>Composite Objects:</strong> In some cases a rigid body consists of parts with
            different densities, for example: A hammer has a metal head and a wooden shaft. To model these
            kind of objects you can create a rigid body with a <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/>. Normally, all
            child object in the <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> have the same density - but: If the child of
            a <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> is a <see cref="T:DigitalRune.Physics.RigidBody"/>, the mass properties of this
            child rigid body are used. Remember: The children of a <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> are of the
            type <see cref="T:DigitalRune.Geometry.IGeometricObject"/> and a <see cref="T:DigitalRune.Physics.RigidBody"/> implements
            <see cref="T:DigitalRune.Geometry.IGeometricObject"/>. Therefore, a <see cref="T:DigitalRune.Physics.RigidBody"/> can be the child of a
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/>. 
            </para>
            <para>
            Now, to model a hammer: Create a rigid body for the metal head. Create a rigid body for the
            wooden shaft. Add both rigid bodies to a <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/>. Call 
            <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/> to compute a <see cref="T:DigitalRune.Physics.MassFrame"/> instance. Then you can
            create the rigid body "hammer" where the shape is the <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> and the 
            <see cref="T:DigitalRune.Physics.MassFrame"/> is the computed mass frame instance. The first two bodies are only
            used to define the composite shape - they are never added to the simulation directly.
            </para>
            <para>
            Whenever <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/> or <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndMass(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/> are called for
            composite shapes, they check if a child shape is a rigid body. And if a child is a rigid body
            the <see cref="T:DigitalRune.Physics.MassFrame"/> of this child rigid body is used directly for this child.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.MassLimit">
            <summary>
            Gets or sets the mass limit. Mass values above this value are treated as infinite.
            </summary>
            <value>The mass limit in the range [0, ∞[. The default is 1e10.</value>
            <remarks>
            <para>
            If a mass value (<see cref="P:DigitalRune.Physics.MassFrame.Mass"/> or an element of <see cref="P:DigitalRune.Physics.MassFrame.Inertia"/>) is above this
            limit, the simulation treats this value as infinite which allows certain optimizations. 
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.Density">
            <summary>
            Gets or sets the density.
            </summary>
            <value>The density. The default value is 1000.</value>
            <remarks>
            If this <see cref="T:DigitalRune.Physics.MassFrame"/> instance was created with <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/>
            the density is the density that was given in the <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/> call.
            If this <see cref="T:DigitalRune.Physics.MassFrame"/> instance was created with <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndMass(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/>
            the density is set to 0 to indicate that the <see cref="T:DigitalRune.Physics.MassFrame"/> was computed for a
            given target mass.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.Mass">
            <summary>
            Gets or sets the mass.
            </summary>
            <value>The mass. The default is 1000.</value>
            <remarks>
            If the mass is 0 or above the <see cref="P:DigitalRune.Physics.MassFrame.MassLimit"/>, the simulation will treat the rigid
            body as a kinematic body (the body will not be moved by simulation forces).
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.MassInverse">
            <summary>
            Gets or sets the inverse of the mass (1 / mass).
            </summary>
            <value>The inverse of the mass (1 / mass).</value>
            <remarks>
            Extreme values (0 mass or very large mass) are clamped to 0.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.Inertia">
            <summary>
            Gets or sets the inertia.
            </summary>
            <value>The inertia.</value>
            <remarks>
            This vector contains the diagonal elements of the diagonalized inertia matrix.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.InertiaInverse">
            <summary>
            Gets or sets the inverse of the inertia.
            </summary>
            <value>The inverse of the inertia.</value>
            <remarks>
            Extreme values (0 mass or very large mass) are clamped to 0.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.MassFrame.Pose">
            <summary>
            Gets or sets the pose that defines the center of mass and the principal axes.
            </summary>
            <value>
            The pose of the space where the center of mass is the origin and the inertia matrix is a 
            diagonal matrix.
            </value>
        </member>
        <member name="M:DigitalRune.Physics.MassFrame.Clone">
            <summary>
            Creates a new <see cref="T:DigitalRune.Physics.MassFrame"/> that is a clone (deep copy) of the current instance.
            </summary>
            <returns>
            A new <see cref="T:DigitalRune.Physics.MassFrame"/> that is a clone (deep copy) of the current instance.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.MassFrame.Adjust(System.Single)">
            <summary>
            Changes the mass so that it is equal to the given target mass and the related properties
            (inertia) are scaled accordingly.
            </summary>
            <param name="targetMass">The target mass.</param>
            <remarks>
            Scaling mass frames is simple: Just change the mass, and scale the inertia by the factor
            <i>m<sub>new</sub> / m<sub>old</sub></i>. This is exactly what this method does.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)">
            <summary>
            Computes a mass frame for the given shape and density.
            </summary>
            <param name="shape">The shape.</param>
            <param name="scale">The scale of the shape.</param>
            <param name="density">The density.</param>
            <param name="relativeDistanceThreshold">
            The relative distance threshold. If no mass or inertia formula for the given shape are known
            the shape is approximated with a triangle mesh and the mass frame of this mesh is returned.
            The relative distance threshold controls the accuracy of the approximated mesh. Good default
            values are 0.05 to get an approximation with an error of about 5%.
            </param>
            <param name="iterationLimit">
            The iteration limit. For some shapes the mass properties are computed with an iterative
            algorithm. No more than <paramref name="iterationLimit"/> iterations will be performed.
            A value of 3 gives good results in most cases. Use a value of -1 to get only a coarse
            approximation.
            </param>
            <returns>
            A new <see cref="T:DigitalRune.Physics.MassFrame"/> for the given parameters is returned.
            </returns>
            <remarks>
            <strong>Composite shapes:</strong> If the given <paramref name="shape"/> is a 
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/>, the computed mass properties are only correct if the children
            of the composite shape do not overlap. Overlapping parts are counted twice and so the result
            will not be correct. If a child of a composite shape is a <see cref="T:DigitalRune.Physics.RigidBody"/> the 
            <see cref="T:DigitalRune.Physics.MassFrame"/> of the rigid body will be used for this child.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="shape"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="density"/> is negative or 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="relativeDistanceThreshold"/> is negative.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.MassFrame.FromShapeAndMass(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)">
            <summary>
            Computes a mass frame for the given shape and target mass.
            </summary>
            <param name="shape">The shape.</param>
            <param name="scale">The scale of the shape.</param>
            <param name="mass">
            The target mass. The mass of the computed <see cref="T:DigitalRune.Physics.MassFrame"/> will be equal to this 
            value. Other mass properties are adjusted to match the target mass.
            </param>
            <param name="relativeDistanceThreshold">
            The relative distance threshold. If no mass or inertia formula for the given shape are known
            the shape is approximated with a triangle mesh and the mass frame of this mesh is returned.
            The relative distance threshold controls the accuracy of the approximated mesh. Good default
            values are 0.05 to get an approximation with an error of about 5%.
            </param>
            <param name="iterationLimit">
            The iteration limit. For some shapes the mass properties are computed with an iterative
            algorithm. No more than <paramref name="iterationLimit"/> iterations will be performed.
            A value of 3 gives good results in most cases. Use a value of -1 to get only a coarse
            approximation.
            </param>
            <returns>
            A new <see cref="T:DigitalRune.Physics.MassFrame"/> for the given parameters is returned.
            </returns>
            <remarks>
            <para>
            <strong>Composite shapes:</strong> If the given <paramref name="shape"/> is a 
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/>, the computed mass properties are only correct if the children
            of the composite shape do not overlap. Overlapping parts are counted twice and so the result
            will not be correct. If a child of a composite shape is a <see cref="T:DigitalRune.Physics.RigidBody"/> the 
            <see cref="T:DigitalRune.Physics.MassFrame"/> of the rigid body will be used for this child.
            </para>
            <para>
            <strong>Density:</strong> Since this method does not use a density value, the 
            <see cref="P:DigitalRune.Physics.MassFrame.Density"/> property of the <see cref="T:DigitalRune.Physics.MassFrame"/> is set to 0.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="shape"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="mass"/> is negative or 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="relativeDistanceThreshold"/> is negative.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.MassFrame.ComputeMassProperties(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Boolean,System.Single,System.Int32)">
            <summary>
            Computes the mass properties for the given shape and parameters.
            </summary>
            <param name="shape">The shape.</param>
            <param name="scale">The scale.</param>
            <param name="densityOrMass">The density or target mass value.</param>
            <param name="isDensity">
            If set to <see langword="true"/> <paramref name="densityOrMass"/> is interpreted as density;
            otherwise, <paramref name="densityOrMass"/> is interpreted as the desired target mass.
            </param>
            <param name="relativeDistanceThreshold">The relative distance threshold.</param>
            <param name="iterationLimit">
            The iteration limit. Can be -1 or 0 to use an approximation.
            </param>
            <returns>
            A new <see cref="T:DigitalRune.Physics.MassFrame"/> instance.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="shape"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="densityOrMass"/> is negative or 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="relativeDistanceThreshold"/> is negative.
            </exception>
        </member>
        <member name="T:DigitalRune.Physics.MassHelper">
            <summary>
            Provides helper methods for computing and manipulating mass properties.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.AdjustMass(System.Single,System.Single@,DigitalRune.Mathematics.Algebra.Matrix33F@)">
            <summary>
            Changes the mass to the given target mass.
            </summary>
            <param name="targetMass">The target mass.</param>
            <param name="mass">The mass.</param>
            <param name="inertia">The inertia.</param>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.DiagonalizeInertia(DigitalRune.Mathematics.Algebra.Matrix33F,DigitalRune.Mathematics.Algebra.Vector3F@,DigitalRune.Mathematics.Algebra.Matrix33F@)">
            <summary>
            Diagonalizes the inertia matrix.
            </summary>
            <param name="inertia">The inertia matrix.</param>
            <param name="inertiaDiagonal">The inertia of the principal axes.</param>
            <param name="rotation">
            The rotation that rotates from principal axis space to parent/world space.
            </param>
            <remarks>
            All valid inertia matrices can be transformed into a coordinate space where all elements
            non-diagonal matrix elements are 0. The axis of this special space are the principal axes.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.GetTranslatedMassInertia(System.Single,DigitalRune.Mathematics.Algebra.Matrix33F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Gets the inertia matrix of mass where the center of mass is moved away from the origin.
            </summary>
            <param name="mass">The mass.</param>
            <param name="inertia">
            The inertia matrix that is valid when the center of mass is in the origin.
            </param>
            <param name="translation">The translation of the center of mass.</param>
            <returns>
            The inertia matrix of the translated mass for rotations around the origin.
            </returns>
            <remarks>
            This method can be used if mass and inertia are given for an object where the center of
            mass is in the origin. The mass is shifted from the origin to the given new position 
            (<paramref name="translation"/>). The new inertia for rotations around the origin is 
            returned.
            </remarks>
            <seealso cref="M:DigitalRune.Physics.MassHelper.GetUntranslatedMassInertia(System.Single,DigitalRune.Mathematics.Algebra.Matrix33F,DigitalRune.Mathematics.Algebra.Vector3F)"/>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.GetUntranslatedMassInertia(System.Single,DigitalRune.Mathematics.Algebra.Matrix33F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Gets the inertia matrix of mass where the center of mass is moved back to the origin.
            </summary>
            <param name="mass">The mass.</param>
            <param name="inertia">
            The inertia matrix for rotations around the origin (not the center of mass) of the 
            translated mass.
            </param>
            <param name="translation">
            The translation of the center of mass. This translation will be undone.
            </param>
            <returns>
            The inertia matrix for rotations around the origin when the center of mass is in the origin.
            </returns>
            <remarks>
            This method does the inverse of <see cref="M:DigitalRune.Physics.MassHelper.GetTranslatedMassInertia(System.Single,DigitalRune.Mathematics.Algebra.Matrix33F,DigitalRune.Mathematics.Algebra.Vector3F)"/>. This method can be 
            used if mass and inertia are given for an object where the center of mass is not in the
            origin and the inertia is given for rotation around the origin. The mass is shifted from
            the translated position (<paramref name="translation"/>) back to the origin and the new
            inertia is returned.
            </remarks>
            <seealso cref="M:DigitalRune.Physics.MassHelper.GetTranslatedMassInertia(System.Single,DigitalRune.Mathematics.Algebra.Matrix33F,DigitalRune.Mathematics.Algebra.Vector3F)"/>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.ComputePolyhedronMassSubExpressions(System.Single,System.Single,System.Single,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Computes the polyhedron mass sub expressions as described in the book "Game Physics".
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.GetMass(DigitalRune.Geometry.Meshes.ITriangleMesh,System.Single@,DigitalRune.Mathematics.Algebra.Vector3F@,DigitalRune.Mathematics.Algebra.Matrix33F@)">
            <summary>
            Gets the mass properties of the given triangle mesh for a density of 1.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="mass">The mass.</param>
            <param name="centerOfMass">The center of mass.</param>
            <param name="inertia">The inertia matrix.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="mesh"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.GetMass(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Boolean,System.Single,System.Int32,System.Single@,DigitalRune.Mathematics.Algebra.Vector3F@,DigitalRune.Mathematics.Algebra.Matrix33F@)">
            <summary>
            Gets the mass properties for the given shape and related properties.
            </summary>
            <param name="shape">The shape.</param>
            <param name="scale">The scale.</param>
            <param name="densityOrMass">The density or mass value.</param>
            <param name="isDensity">
            If set to <see langword="true"/> <paramref name="densityOrMass"/> is treated as density;
            otherwise, the value is used for the target mass.
            </param>
            <param name="relativeDistanceThreshold">
            The relative distance threshold for shape approximations.
            </param>
            <param name="iterationLimit">
            The iteration limit. Can be 0 or -1 to use approximate mass properties.
            </param>
            <param name="mass">The mass.</param>
            <param name="centerOfMass">The center of mass.</param>
            <param name="inertia">The inertia.</param>
            <remarks>
            <para>
            This method computes <paramref name="mass"/>, <paramref name="centerOfMass"/> and the 
            <paramref name="inertia"/> matrix for the local space of the shape.
            </para>
            <para>
            If the <paramref name="shape"/> is a composite shape and a child geometric object is a
            rigid body, the mass properties of the rigid body are used for the child. Otherwise, new
            child mass properties are computed.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="shape"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="densityOrMass"/> is negative or 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="relativeDistanceThreshold"/> is negative.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.GetMass(DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Boolean,System.Single@,DigitalRune.Mathematics.Algebra.Matrix33F@)">
            <summary>
            Gets the mass properties of a box.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.MassHelper.GetMass(DigitalRune.Geometry.IGeometricObject,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Boolean,System.Single,System.Int32,System.Single@,DigitalRune.Mathematics.Algebra.Vector3F@,DigitalRune.Mathematics.Algebra.Matrix33F@)">
            <summary>
            Gets the mass properties of a geometric object.
            </summary>
            <remarks>
            If the geometric object is a <see cref="T:DigitalRune.Physics.RigidBody"/>, the mass frame of the this rigid body
            is used. If the geometric object is not a <see cref="T:DigitalRune.Physics.RigidBody"/> the mass is computed
            for the contained shape.
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.Materials.CompositeMaterial">
            <summary>
            Defines a material with different materials for each shape feature of a rigid body.
            </summary>
            <remarks>
            <para>
            This material can be used with rigid bodies that have a complex shape, e.g. a 
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> or a <see cref="T:DigitalRune.Geometry.Shapes.TriangleMeshShape"/>. The features of a 
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> are the <see cref="P:DigitalRune.Geometry.Shapes.CompositeShape.Children"/> of the composite
            shape. The features of a <see cref="T:DigitalRune.Geometry.Shapes.TriangleMeshShape"/> are the triangles of the mesh. 
            </para>
            <para>
            The <see cref="P:DigitalRune.Physics.Materials.CompositeMaterial.Materials"/> list can store a material for each feature of a complex shape. 
            </para>
            <para>
            To determine the material for a shape feature, the <see cref="T:DigitalRune.Physics.Materials.CompositeMaterial"/> first 
            checks if the <see cref="P:DigitalRune.Physics.Materials.CompositeMaterial.Materials"/> list has an entry for this shape. If the list has less 
            elements than the shape has features or the material is <see langword="null"/>, the 
            <see cref="T:DigitalRune.Physics.Materials.CompositeMaterial"/> checks whether the shape of the rigid body is a 
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> and the given shape features is of type <see cref="T:DigitalRune.Physics.RigidBody"/>.
            If the shape feature is a rigid body instance, the material of this rigid body instance is 
            used. In all other cases the <see cref="P:DigitalRune.Physics.Materials.CompositeMaterial.DefaultMaterial"/> is used.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Materials.CompositeMaterial.DefaultMaterial">
            <summary>
            Gets the default material that is used for shape features that have no entry
            in <see cref="P:DigitalRune.Physics.Materials.CompositeMaterial.Materials"/>.
            </summary>
            <value>
            The default material. The default value is a new instance of <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Materials.CompositeMaterial.Materials">
            <summary>
            Gets the list of materials for the shape features.
            </summary>
            <value>The materials for the shape features.</value>
            <remarks>
            Example: If this material is used for a rigid body with a <see cref="T:DigitalRune.Geometry.Shapes.TriangleMeshShape"/>,
            the 9th item in this list defines the material of the 9th triangle in the triangle mesh. If
            this list has less items than the number of triangles or the item is <see langword="null"/>,
            the <see cref="P:DigitalRune.Physics.Materials.CompositeMaterial.DefaultMaterial"/> is used for the other triangles.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Materials.CompositeMaterial.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.CompositeMaterial"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.CompositeMaterial"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Materials.CompositeMaterial.#ctor(DigitalRune.Physics.Materials.UniformMaterial)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.CompositeMaterial"/> class.
            </summary>
            <param name="defaultMaterial">The default material.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="defaultMaterial"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Materials.CompositeMaterial.GetProperties(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,System.Int32)">
            <summary>
            Gets the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> for the given rigid body, position and shape
            feature.
            </summary>
            <param name="body">The rigid body.</param>
            <param name="positionLocal">
            The local position on the rigid body for which the material properties should be returned.
            </param>
            <param name="featureIndex">
            The index of the shape feature from which the material properties are needed. For a
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> the feature index is the index of the child of the composite
            shape. For a <see cref="T:DigitalRune.Geometry.Shapes.TriangleMeshShape"/> the feature index is the index of a triangle.
            </param>
            <returns>
            The <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> of the given rigid body at the given position and 
            child feature.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="body"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:DigitalRune.Physics.Materials.IMaterial">
            <summary>
            Defines the material (friction, bounciness, etc.) of a rigid body.
            </summary>
            <remarks>
            <para>
            A <see cref="T:DigitalRune.Physics.Materials.IMaterial"/> defines the material properties of a rigid body. In simple cases the
            material properties of a rigid body are constant for the whole rigid body. In complex cases
            different parts of a single rigid body can have different properties or the material
            properties can change depending on the simulation time or other parameters.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Materials.IMaterial.GetProperties(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,System.Int32)">
            <summary>
            Gets the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> for the given rigid body, position and shape
            feature.
            </summary>
            <param name="body">The rigid body.</param>
            <param name="positionLocal">
            The local position on the rigid body for which the material properties should be returned.
            </param>
            <param name="featureIndex">
            The index of the shape feature from which the material properties are needed. For a
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> the feature index is the index of the child of the composite
            shape. For a <see cref="T:DigitalRune.Geometry.Shapes.TriangleMeshShape"/> the feature index is the index of a triangle.
            </param>
            <returns>
            The <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> of the given rigid body at the given position and 
            child feature.
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.Materials.IMaterialPropertyCombiner">
            <summary>
            Computes the material properties for two materials in contact.
            </summary>
            <remarks>
            <para>
            Many material properties depend on two objects. For example, the friction of ice on rubber is
            different from rubber on rubber. The material property combiner computes the coefficient that
            is actually used in the simulation to simulate the physical behavior at a contact.
            </para>
            <para>
            Combining material coefficients can be done in different ways. The accurate way would be to
            look up the exact value in a material table. The simple way is to use a mathematical operation
            to combine the coefficients, e.g. multiply both coefficients or compute the average. For most
            scenarios in games, the latter method is sufficient.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Materials.IMaterialPropertyCombiner.CombineFriction(System.Single,System.Single)">
            <summary>
            Computes the combined friction coefficient.
            </summary>
            <param name="frictionA">The first friction coefficient.</param>
            <param name="frictionB">The second friction coefficient.</param>
            <returns>
            The combined friction coefficient.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Materials.IMaterialPropertyCombiner.CombineRestitution(System.Single,System.Single)">
            <summary>
            Computes the combined coefficient of restitution.
            </summary>
            <param name="restitutionA">The first coefficient of restitution.</param>
            <param name="restitutionB">The second coefficient of restitution.</param>
            <returns>
            The combined coefficient of restitution.
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.Materials.MaterialProperties">
            <summary>
            Defines material properties of a rigid body.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialProperties.StaticFriction">
            <summary>
            Gets or sets the static friction coefficient.
            </summary>
            <value>
            The static friction coefficient in the range [0, ∞[.
            </value>
            <remarks>
            Dry friction resists relative lateral motion of two solid surfaces in contact. Dry 
            friction is subdivided into static friction between non-moving surfaces and dynamic 
            friction between moving surfaces.
            </remarks>
            <seealso cref="P:DigitalRune.Physics.Materials.MaterialProperties.DynamicFriction"/>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialProperties.DynamicFriction">
            <summary>
            Gets or sets the dynamic friction (kinetic friction) coefficient.
            </summary>
            <value>
            The dynamic friction coefficient in the range [0, ∞[.
            </value>
            <remarks>
            Dry friction resists relative lateral motion of two solid surfaces in contact. Dry 
            friction is subdivided into static friction between non-moving surfaces and dynamic 
            friction between moving surfaces.
            </remarks>
            <seealso cref="P:DigitalRune.Physics.Materials.MaterialProperties.StaticFriction"/>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialProperties.Restitution">
            <summary>
            Gets or sets the coefficient of restitution (bounciness).
            </summary>
            <value>The coefficient of restitution in the range [0, 1].</value>
            <remarks>
            <para>
            The coefficient of restitution or bounciness of an object is a fractional value 
            representing the ratio of velocities after and before an impact. An object with a
            restitution of 1 collides elastically, while an object with a restitution less than 1
            collides inelastically. For a value of 0, the object effectively "stops" at the surface
            with which it collides - not bouncing at all.
            </para>
            <para>
            For a stable simulation it is recommended to use 0 or low values when possible.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialProperties.SupportsSurfaceMotion">
            <summary>
            Gets or sets a value indicating whether this material supports surface motion.
            </summary>
            <value>
            <see langword="true"/> if this material supports surface motion; otherwise, 
            <see langword="false"/>.
            </value>
            <remarks>
            This flag indicates whether the material supports a surface motion - it does not indicate if
            the current <see cref="P:DigitalRune.Physics.Materials.MaterialProperties.SurfaceMotion"/> is non-zero. The simulation has optimizations for
            contacts where materials will never have a surface motion. If a material will at any time 
            use a non-zero surface motion this flag must be set to <see langword="true"/>, even if the 
            current surface motion velocity is zero.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialProperties.SurfaceMotion">
            <summary>
            Gets or sets the velocity of the rigid body surface (in local space of the body).
            </summary>
            <value>
            A velocity that describes the speed and direction in which the surface is moving relative
            to the rigid body. The default value is a (0, 0, 0).
            </value>
            <remarks>
            This property can be used to simulate conveyor belts or similar objects.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.#ctor(System.Single,System.Single,System.Single)">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> structure.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> structure.
            </summary>
            <param name="staticFriction">The static friction.</param>
            <param name="dynamicFriction">The dynamic friction.</param>
            <param name="restitution">The coefficient of restitution.</param>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.#ctor(System.Single,System.Single,System.Single,System.Boolean,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> structure.
            </summary>
            <param name="staticFriction">The static friction.</param>
            <param name="dynamicFriction">The dynamic friction.</param>
            <param name="restitution">The coefficient of restitution.</param>
            <param name="supportsSurfaceMotion">
            If set to <see langword="true"/> the material supports surface motion.
            </param>
            <param name="surfaceMotion">The surface motion velocity.</param>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.#ctor(System.Single,System.Single,System.Single,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> structure.
            </summary>
            <param name="staticFriction">The static friction.</param>
            <param name="dynamicFriction">The dynamic friction.</param>
            <param name="restitution">The coefficient of restitution.</param>
            <param name="surfaceMotion">The surface motion velocity.</param>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.Equals(DigitalRune.Physics.Materials.MaterialProperties)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <see langword="true"/> if the current object is equal to the <paramref name="other" />
            parameter; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            <see langword="true"/> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures
            like a hash table. 
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.op_Equality(DigitalRune.Physics.Materials.MaterialProperties,DigitalRune.Physics.Materials.MaterialProperties)">
            <summary>
            Compares <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> to determine whether they are the same.
            </summary>
            <param name="left">The first <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/>.</param>
            <param name="right">The second <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/>.</param>
            <returns>
            <see langword="true"/> if the <paramref name="left"/> and <paramref name="right"/> are the 
            same; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialProperties.op_Inequality(DigitalRune.Physics.Materials.MaterialProperties,DigitalRune.Physics.Materials.MaterialProperties)">
            <summary>
            Compares <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> to determine whether they are different.
            </summary>
            <param name="left">The first <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/>.</param>
            <param name="right">The second <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/>.</param>
            <returns>
            <see langword="true"/> if the <paramref name="left"/> and <paramref name="right"/> are 
            different; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.Materials.MaterialPropertyCombiner">
            <summary>
            Computes the material properties for two materials in contact using simple mathematical
            operations.
            </summary>
            <remarks>
            Two given coefficients are combined using a simple mathematical operation 
            (see <see cref="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.FrictionMode"/>, <see cref="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.RestitutionMode"/>) and the result is clamped. 
            Friction is clamped to the range [<see cref="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.MinFriction"/>, <see cref="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.MaxFriction"/>]. 
            Restitution is clamped to the range [0, <see cref="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.MaxRestitution"/>].
            </remarks>
        </member>
        <member name="T:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode">
            <summary>
            Defines how two coefficients are combined.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.Add">
            <summary>Use the sum of the two coefficients.</summary>
        </member>
        <member name="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.Min">
            <summary>Use the minimum of the two coefficients.</summary>
        </member>
        <member name="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.Max">
            <summary>Use the maximum of the two coefficients.</summary>
        </member>
        <member name="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.ArithmeticMean">
            <summary>Use the arithmetic mean (average) of the two coefficients.</summary>
        </member>
        <member name="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.GeometricMean">
            <summary>Use the geometric mean of the two coefficients.</summary>
        </member>
        <member name="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.Multiply">
            <summary>Use the product of the two coefficients.</summary>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.FrictionMode">
            <summary>
            Gets or sets the mode that is used to combine friction coefficients.
            </summary>
            <value>
            The mode that is used to combine friction coefficients.
            The default is <see cref="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.GeometricMean"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.MinFriction">
            <summary>
            Gets or sets the minimal friction value.
            </summary>
            <value>The minimal friction value. The default value is 0.</value>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.MaxFriction">
            <summary>
            Gets or sets the maximal friction value.
            </summary>
            <value>The maximal friction value. The default value is 10.</value>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.RestitutionMode">
            <summary>
            Gets or sets the mode that is used to combine coefficients of restitution.
            </summary>
            <value>
            The mode that is used to combine coefficients of restitution.
            The default is <see cref="F:DigitalRune.Physics.Materials.MaterialPropertyCombiner.Mode.Multiply"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.Materials.MaterialPropertyCombiner.MaxRestitution">
            <summary>
            Gets or sets the maximal restitution value.
            </summary>
            <value>The maximal restitution value. The default value is 1.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialPropertyCombiner.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.MaterialPropertyCombiner"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialPropertyCombiner.CombineFriction(System.Single,System.Single)">
            <summary>
            Computes the combined friction coefficient.
            </summary>
            <param name="frictionA">The first friction coefficient.</param>
            <param name="frictionB">The second friction coefficient.</param>
            <returns>
            The combined friction coefficient.
            </returns>
        </member>
        <member name="M:DigitalRune.Physics.Materials.MaterialPropertyCombiner.CombineRestitution(System.Single,System.Single)">
            <summary>
            Computes the combined coefficient of restitution.
            </summary>
            <param name="restitutionA">The first coefficient of restitution.</param>
            <param name="restitutionB">The second coefficient of restitution.</param>
            <returns>
            The combined coefficient of restitution.
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.Materials.NamespaceDoc">
            <summary>
            The <see cref="N:DigitalRune.Physics.Materials"/> namespace provides types that define
            material properties of physical objects.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Materials.UniformMaterial">
            <summary>
            Defines a <see cref="T:DigitalRune.Physics.Materials.IMaterial"/> with constant material properties for the whole rigid body.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.Materials.UniformMaterial.StaticFriction">
            <summary>
            Gets or sets the static friction coefficient.
            </summary>
            <value>
            The static friction coefficient in the range [0, ∞[.
            The default value is 0.5.
            </value>
            <remarks>
            Dry friction resists relative lateral motion of two solid surfaces in contact. Dry 
            friction is subdivided into static friction between non-moving surfaces and dynamic 
            friction between moving surfaces.
            </remarks>
            <seealso cref="P:DigitalRune.Physics.Materials.UniformMaterial.DynamicFriction"/>
        </member>
        <member name="P:DigitalRune.Physics.Materials.UniformMaterial.DynamicFriction">
            <summary>
            Gets or sets the dynamic friction (kinetic friction) coefficient.
            </summary>
            <value>
            The dynamic friction coefficient in the range [0, ∞[.
            The default value is 0.5.
            </value>
            <remarks>
            Dry friction resists relative lateral motion of two solid surfaces in contact. Dry 
            friction is subdivided into static friction between non-moving surfaces and dynamic 
            friction between moving surfaces.
            </remarks>
            <seealso cref="P:DigitalRune.Physics.Materials.UniformMaterial.StaticFriction"/>
        </member>
        <member name="P:DigitalRune.Physics.Materials.UniformMaterial.Restitution">
            <summary>
            Gets or sets the coefficient of restitution (bounciness).
            </summary>
            <value>
            The coefficient of restitution in the range [0, 1]. The default value is 0.1.
            </value>
            <remarks>
            <para>
            The coefficient of restitution or bounciness of an object is a fractional value 
            representing the ratio of velocities after and before an impact. An object with a
            restitution of 1 collides elastically, while an object with a restitution less than 1
            collides inelastically. For a value of 0, the object effectively "stops" at the surface
            with which it collides - not bouncing at all.
            </para>
            <para>
            For a stable simulation it is recommended to use 0 or low values when possible.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Materials.UniformMaterial.SupportsSurfaceMotion">
            <summary>
            Gets a value indicating whether this material supports surface motion.
            </summary>
            <value>
            <see langword="true"/> if this material supports surface motion; otherwise, 
            <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            <para>
            This flag indicates whether the material supports a surface motion - it does not indicate if
            the current <see cref="P:DigitalRune.Physics.Materials.UniformMaterial.SurfaceMotion"/> is non-zero. The simulation has optimizations for
            contacts where materials will never have a surface motion. If a material will at any time 
            use a non-zero surface motion this flag must be set to <see langword="true"/>, even if the 
            current surface motion velocity is zero.
            </para>
            <para>
            This flag is read-only and can only be set in the constructor of this class.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Materials.UniformMaterial.SurfaceMotion">
            <summary>
            Gets or sets the velocity of the rigid body surface (in local space of the body).
            </summary>
            <value>
            A velocity that describes the speed and the direction in which the surface is moving 
            relative to the rigid body. The default value is a (0, 0, 0).
            </value>
            <remarks>
            This property can be used to simulate conveyor belts or similar objects.
            </remarks>
            <exception cref="T:DigitalRune.Physics.PhysicsException">
            This material does not support surface motion. (<see cref="P:DigitalRune.Physics.Materials.UniformMaterial.SupportsSurfaceMotion"/> is 
            <see langword="false"/>.)
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Materials.UniformMaterial.Name">
            <summary>
            Gets or sets the name of the material.
            </summary>
            <value>
            The name of the material, for example "Wood", "Ice". The default value is
            <see langword="null"/>.
            </value>
            <remarks>
            This property is not used by the simulation. It can be used to manage different materials
            and for debugging.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Materials.UniformMaterial.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/> class.
            </summary>
            <remarks>
            The created material does not support <see cref="P:DigitalRune.Physics.Materials.UniformMaterial.SurfaceMotion"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Materials.UniformMaterial.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/> class.
            </summary>
            <param name="name">The name of the material. Can be <see langword="null"/>.</param>
        </member>
        <member name="M:DigitalRune.Physics.Materials.UniformMaterial.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/> class.
            </summary>
            <param name="name">The name of the material. Can be <see langword="null"/>.</param>
            <param name="supportsSurfaceMotion">
            If set to <see langword="true"/> the material supports surface motion. See also
            <see cref="P:DigitalRune.Physics.Materials.UniformMaterial.SupportsSurfaceMotion"/> and <see cref="P:DigitalRune.Physics.Materials.UniformMaterial.SurfaceMotion"/>.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.Materials.UniformMaterial.#ctor(DigitalRune.Physics.Materials.UniformMaterial)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/> class from a given material.
            </summary>
            <param name="material">The material from which the properties are copied.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="material"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Materials.UniformMaterial.#ctor(System.String,DigitalRune.Physics.Materials.MaterialProperties)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/> class from a given material.
            </summary>
            <param name="name">The name of the material. Can be <see langword="null"/>.</param>
            <param name="material">The material from which the properties are copied.</param>
        </member>
        <member name="M:DigitalRune.Physics.Materials.UniformMaterial.GetProperties(DigitalRune.Physics.RigidBody,DigitalRune.Mathematics.Algebra.Vector3F,System.Int32)">
            <summary>
            Gets the <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> for the given rigid body, position and shape
            feature.
            </summary>
            <param name="body">The rigid body.</param>
            <param name="positionLocal">
            The local position on the rigid body for which the material properties should be returned.
            </param>
            <param name="featureIndex">
            The index of the shape feature from which the material properties are needed. For a
            <see cref="T:DigitalRune.Geometry.Shapes.CompositeShape"/> the feature index is the index of the child of the composite
            shape. For a <see cref="T:DigitalRune.Geometry.Shapes.TriangleMeshShape"/> the feature index is the index of a triangle.
            </param>
            <returns>
            The <see cref="T:DigitalRune.Physics.Materials.MaterialProperties"/> of the given rigid body at the given position and
            child feature.
            </returns>
        </member>
        <member name="T:DigitalRune.Physics.MotionType">
            <summary>
            Defines how the simulation computes the rigid body movement.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.MotionType.Static">
            <summary>
            The body is static. It will never move.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.MotionType.Kinematic">
            <summary>
            The body is kinematic. Its movement is controlled by the user, not by simulation forces.
            </summary>
        </member>
        <member name="F:DigitalRune.Physics.MotionType.Dynamic">
            <summary>
            The body is dynamic. Its movement is controlled by the simulation forces and collision 
            response.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.NamespaceDoc">
            <summary>
            The <see cref="N:DigitalRune.Physics"/> namespace provides types for physics simulation,
            especially rigid body dynamics.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.PhysicsException">
            <summary>
            The exception that is thrown when a general error in the physics library occurs.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.PhysicsException.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.PhysicsException"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.PhysicsException"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.PhysicsException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.PhysicsException"/> class with a specified 
            error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:DigitalRune.Physics.PhysicsException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.PhysicsException"/> class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">
            The exception that is the cause of the current exception, or <see langword="null"/> if no
            inner exception is specified.
            </param>
        </member>
        <member name="T:DigitalRune.Physics.RigidBody">
            <summary>
            Represents a rigid body.
            </summary>
            <remarks>
            <para>
            A rigid body is a body that is simulated by rigid body dynamics. The body has a 
            <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> that is constant for the simulation (although the shape can be exchanged
            by the user). No deformations are computed, therefore this body cannot model a soft body like
            cloth or fluids.
            </para>
            <para>
            The body also has a mass properties defined in <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> and a 
            <see cref="P:DigitalRune.Physics.RigidBody.Material"/> that defines friction, bounciness and other material properties.
            </para>
            <para>
            <strong>Center Of Mass:</strong> The body has a <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> that defines its position
            and orientation in world space. The origin of the local space of the body can be different
            from its center of mass. The body has a <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> that defines the pose
            of the center of mass in world space. The center of mass is automatically computed from the
            shape of the rigid body when the body's <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> is created. To move the rigid
            body to a new pose the properties <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> or <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> can be 
            used; the two properties are synchronized automatically.
            </para>
            <para>
            <strong>Collision Detection:</strong> The rigid body class implements 
            <see cref="T:DigitalRune.Geometry.IGeometricObject"/> and it automatically creates a <see cref="P:DigitalRune.Physics.RigidBody.CollisionObject"/>
            for the rigid body. This collision object is automatically added to the
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/> of the simulation.
            </para>
            <para>
            <strong>Important:</strong> An <see cref="T:DigitalRune.Geometry.IGeometricObject"/> instance registers event
            handlers for the <see cref="E:DigitalRune.Geometry.Shapes.Shape.Changed"/> event of the contained
            <see cref="P:DigitalRune.Physics.RigidBody.Shape"/>. Therefore, a <see cref="T:DigitalRune.Geometry.Shapes.Shape"/> will have an indirect
            reference to the <see cref="T:DigitalRune.Geometry.IGeometricObject"/>. This is no problem if the geometric object
            exclusively owns the shape. However, this could lead to problems ("life extension bugs" a.k.a.
            "memory leaks") when multiple geometric objects share the same shape: One geometric object is
            no longer used but it cannot be collected by the garbage collector because the shape still
            holds a reference to the object.
            </para>
            <para>
            Therefore, when <see cref="T:DigitalRune.Geometry.Shapes.Shape"/>s are shared between multiple
            <see cref="T:DigitalRune.Geometry.IGeometricObject"/>s: Always set the property <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> to
            <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/> when the <see cref="T:DigitalRune.Geometry.IGeometricObject"/>
            is no longer used. <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/> is a special
            immutable shape that never raises any <see cref="E:DigitalRune.Geometry.Shapes.Shape.Changed"/> events.
            Setting <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> to <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/> ensures that the
            internal event handlers are unregistered and the object can be garbage-collected properly.
            </para>
            <para>
            <strong>Cloning:</strong> The rigid body can be cloned using the <see cref="M:DigitalRune.Physics.RigidBody.Clone"/> method.
            Cloning creates a deep copy of the object. The <see cref="P:DigitalRune.Physics.RigidBody.UserData"/> and the
            <see cref="P:DigitalRune.Physics.RigidBody.Material"/> are copied and not cloned, so the clone will refer to the
            same <see cref="P:DigitalRune.Physics.RigidBody.UserData"/> and <see cref="P:DigitalRune.Physics.RigidBody.Material"/> instances. All other properties are
            properly cloned.
            </para>
            <para>
            <strong>Sleeping:</strong> See also <see cref="T:DigitalRune.Physics.Settings.SleepingSettings"/>. The rigid body 
            automatically wakes up if important properties are changed - for example, if the 
            <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> is changed, the body wakes up.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.CollisionObject">
            <summary>
            Gets the collision object.
            </summary>
            <value>The collision object.</value>
            <remarks>
            This collision object is automatically created and added to the 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/> of the simulation when the rigid body is
            added to a simulation. 
            <see cref="P:DigitalRune.Physics.RigidBody.CollisionObject"/>.<see cref="P:DigitalRune.Geometry.Collisions.CollisionObject.GeometricObject"/> 
            refers to this rigid body instance.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.CollisionResponseEnabled">
            <summary>
            Gets or sets a value indicating whether collision response is enabled.
            </summary>
            <value>
            <see langword="true"/> if the collision response is enabled; otherwise, 
            <see langword="false"/>. The default value is <see langword="true"/>.
            </value>
            <remarks>
            If collision response is disabled, no <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/>s are created for this
            rigid body, and the simulation will not stop the body from moving through other rigid
            bodies. Disabling collision response only make sense if there is no <see cref="T:DigitalRune.Physics.ForceEffects.Gravity"/> in
            the simulated world or if the body is held in place by constraints or other forces. Without 
            constraints or forces the body will just fall through the floor and nothing will stop it.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Material">
            <summary>
            Gets or sets the material.
            </summary>
            <value>
            The material. The default value is a new instance of <see cref="T:DigitalRune.Physics.Materials.UniformMaterial"/>.
            </value>
            <remarks>
            The material defines the surface friction, bounciness and other properties. See
            <see cref="T:DigitalRune.Physics.Materials.IMaterial"/>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.MotionType">
            <summary>
            Gets or sets the motion type.
            </summary>
            <value>The motion type. The default is <see cref="F:DigitalRune.Physics.MotionType.Dynamic"/>.</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Name">
            <summary>
            Gets the name.
            </summary>
            <value>The name of this rigid body. The default is "Unnamed".</value>
            <remarks>
            This property can be used for debugging or other purposes. It is not used by the physics 
            simulation.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Simulation">
            <summary>
            Gets the simulation.
            </summary>
            <value>The simulation.</value>
            <remarks>
            This property is set if this body is in a <see cref="P:DigitalRune.Physics.Simulation.RigidBodies"/> 
            collection of a simulation. Otherwise it is <see langword="null"/>.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.UserData">
            <summary>
            Gets or sets the user data.
            </summary>
            <value>The user data.</value>
            <remarks>
            <para>
            This property can store end-user data. This property is not used by the physics simulation.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.IslandId">
            <summary>
            Gets or sets the island ID.
            </summary>
            <value>The island ID.</value>
            <remarks>
            Kinematic/static bodies have ID -1.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.BuoyancyData">
            <summary>
            Gets or sets the buoyancy data.
            </summary>
            <value>The buoyancy data.</value>
            <remarks>
            This is normally not set. The data is initialized when the body touches the water surface of
            a <see cref="T:DigitalRune.Physics.ForceEffects.Buoyancy"/> effect or when <see cref="M:DigitalRune.Physics.ForceEffects.Buoyancy.Prepare(DigitalRune.Physics.RigidBody)"/> is called. The data
            is invalidated when the shape of the rigid body is changed.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.#ctor">
            <overloads>
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </summary>
            </overloads>
            
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.#ctor(DigitalRune.Geometry.Shapes.Shape)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </summary>
            <param name="shape">
            The shape. Can be <see langword="null"/> to use the default <see cref="P:DigitalRune.Physics.RigidBody.Shape"/>.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.#ctor(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Physics.MassFrame,DigitalRune.Physics.Materials.IMaterial)">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.RigidBody"/> class.
            </summary>
            <param name="shape">
            The shape. Can be <see langword="null"/> to use the default <see cref="P:DigitalRune.Physics.RigidBody.Shape"/>.
            </param>
            <param name="massFrame">
            The mass frame. Can be <see langword="null"/> in which case the mass properties for a
            density of 1000 are used.
            </param>
            <param name="material">
            The material. Can be <see langword="null"/> to use the default <see cref="P:DigitalRune.Physics.RigidBody.Material"/>.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.OnAddToSimulation">
            <summary>
            Called when this rigid body is added to a simulation.
            </summary>
            <remarks>
            <para>
            The simulation to which the rigid body is added is set in the property 
            <see cref="P:DigitalRune.Physics.RigidBody.Simulation"/>.
            </para>
            <para>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.RigidBody.OnAddToSimulation"/> in a 
            derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.RigidBody.OnAddToSimulation"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.OnRemoveFromSimulation">
            <summary>
            Called when this rigid body is removed from a simulation.
            </summary>
            <remarks>
            <para>
            The simulation from which the rigid body is removed is set in the property 
            <see cref="P:DigitalRune.Physics.RigidBody.Simulation"/>. After <see cref="M:DigitalRune.Physics.RigidBody.OnRemoveFromSimulation"/> the property 
            <see cref="P:DigitalRune.Physics.RigidBody.Simulation"/> will be reset to <see langword="null"/>.
            <para>
            </para>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.RigidBody.OnRemoveFromSimulation"/>
            in a derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.RigidBody.OnRemoveFromSimulation"/>
            method.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.ClearForces">
            <summary>
            Clears all forces that were set with <see cref="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/>,
            <see cref="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F)"/> or <see cref="M:DigitalRune.Physics.RigidBody.AddTorque(DigitalRune.Mathematics.Algebra.Vector3F)"/>.
            </summary>
            <remarks>
            Forces are automatically cleared at the end of a simulation time step.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <overloads>
            <summary>
            Applies a force to the rigid body.
            </summary>
            </overloads>
            
            <summary>
            Applies a force to the rigid body.
            </summary>
            <param name="forceWorld">The force in world space.</param>
            <param name="positionWorld">
            The position where the force is applied in world space.
            </param>
            <remarks>
            The force will influence the body in the next time step. The same force is applied for all
            internal sub time steps and the forces will be cleared at the end of a time step. If a
            permanent force should act on the rigid body, the method 
            <see cref="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/> must be called before each time step - or a 
            <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> can be used instead.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a force at the center of mass of the rigid body.
            </summary>
            <param name="forceWorld">The force in world space.</param>
            <remarks>
            The force will influence the body in the next time step. The same force is applied for all
            internal sub time steps and the forces will be cleared at the end of a time step. If a
            permanent force should act on the rigid body, the method 
            <see cref="M:DigitalRune.Physics.RigidBody.AddForce(DigitalRune.Mathematics.Algebra.Vector3F)"/> must be called before each time step - or a 
            <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> can be used instead.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.AddTorque(DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a torque at the center of mass of the rigid body.
            </summary>
            <param name="torqueWorld">The torque in world space.</param>
            <remarks>
            The torque will influence the body in the next time step. The same torque is applied for all
            internal sub time steps and the torques will be cleared at the end of a time step. If a
            permanent torque should act on the rigid body, the method <see cref="M:DigitalRune.Physics.RigidBody.AddTorque(DigitalRune.Mathematics.Algebra.Vector3F)"/> must be
            called before each time step - or a <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> can be used instead.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.DigitalRune#Geometry#IGeometricObject#Clone">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.Clone">
            <summary>
            Creates a new <see cref="T:DigitalRune.Physics.RigidBody"/> that is a clone (deep copy) of the current instance.
            </summary>
            <returns>
            A new <see cref="T:DigitalRune.Physics.RigidBody"/> that is a clone (deep copy) of the current instance.
            </returns>
            <remarks>
            <strong>Notes to Inheritors:</strong> The method <see cref="M:DigitalRune.Physics.RigidBody.Clone"/> calls 
            <see cref="M:DigitalRune.Physics.RigidBody.CreateInstanceCore"/> which is responsible for creating a new instance of the 
            <see cref="T:DigitalRune.Physics.RigidBody"/> derived class and <see cref="M:DigitalRune.Physics.RigidBody.CloneCore(DigitalRune.Physics.RigidBody)"/> to create a copy of the
            current instance. Classes that derive from <see cref="T:DigitalRune.Physics.RigidBody"/> need to implement 
            <see cref="M:DigitalRune.Physics.RigidBody.CreateInstanceCore"/> and <see cref="M:DigitalRune.Physics.RigidBody.CloneCore(DigitalRune.Physics.RigidBody)"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.CreateInstance">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.RigidBody"/> class. 
            </summary>
            <returns>The new instance.</returns>
            <remarks>
            This is a protected method, and the actual object-specific implementations for the behavior 
            are dependent on the override implementation of the <see cref="M:DigitalRune.Physics.RigidBody.CreateInstanceCore"/> method, 
            which this method calls internally. 
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Cannot clone shape. A class derived from <see cref="T:DigitalRune.Physics.RigidBody"/> does not implement 
            <see cref="M:DigitalRune.Physics.RigidBody.CreateInstanceCore"/>."
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.CreateInstanceCore">
            <summary>
            When implemented in a derived class, creates a new instance of the 
            <see cref="T:DigitalRune.Physics.RigidBody"/> derived class. 
            </summary>
            <returns>The new instance.</returns>
            <remarks>
            <para>
            Do not call this method directly (except when calling base in an implementation). This 
            method is called internally by the <see cref="M:DigitalRune.Physics.RigidBody.Clone"/> method whenever a new instance of the
            <see cref="T:DigitalRune.Physics.RigidBody"/> is created. 
            </para>
            <para>
            <strong>Notes to Inheritors:</strong> Every <see cref="T:DigitalRune.Physics.RigidBody"/> derived class must
            implement this method. A typical implementation is to simply call the default constructor
            and return the result. 
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.CloneCore(DigitalRune.Physics.RigidBody)">
            <summary>
            Makes the instance a clone (deep copy) of the specified <see cref="T:DigitalRune.Physics.RigidBody"/>.
            </summary>
            <param name="source">The object to clone.</param>
            <remarks>
            <strong>Notes to Inheritors:</strong> Every <see cref="T:DigitalRune.Physics.RigidBody"/> derived class must
            implement this method. A typical implementation is to call <c>base.CloneCore(this)</c> to
            copy all properties of the base class and then copy all properties of the derived class.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Aabb">
            <summary>
            Gets the axis-aligned bounding box (AABB).
            </summary>
            <value>The axis-aligned bounding box (AABB).</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Pose">
            <summary>
            Gets or sets the pose (position and orientation).
            </summary>
            <value>The pose (position and orientation).</value>
            <remarks>
            Changing this property raises the <see cref="E:DigitalRune.Physics.RigidBody.PoseChanged"/> event.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass">
            <summary>
            Gets or sets the pose (position and orientation) of the center of mass.
            </summary>
            <value>The pose (position and orientation) of the center of mass.</value>
            <remarks>
            <para>
            This center of mass is relative to the origin of the local space of the body and is defined
            in the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>. The property <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> describes the
            pose of the center of mass in world space - not in local space. Changing this property
            automatically updates <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> and vice versa. Changing this property moves the 
            whole body in the world - it does not shift the center of mass inside body.
            </para>
            <para>
            Changing this property raises the <see cref="E:DigitalRune.Physics.RigidBody.PoseChanged"/> event.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.TargetPose">
            <summary>
            Gets or sets the target pose for CCD objects - used during motion clamping.
            </summary>
            <value>The target pose.</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Shape">
            <summary>
            Gets or sets the shape.
            </summary>
            <value>
            The shape. The shape must not be <see langword="null"/>, but it can be of type
            <see cref="T:DigitalRune.Geometry.Shapes.EmptyShape"/> (see <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/>. 
            The default value is a cube with side length 1.
            </value>
            <remarks>
            <para>
            Changing this property raises the <see cref="E:DigitalRune.Physics.RigidBody.ShapeChanged"/> event.
            </para>
            <para>
            <strong>Important:</strong> An <see cref="T:DigitalRune.Geometry.IGeometricObject"/> instance registers event 
            handlers for the <see cref="E:DigitalRune.Geometry.Shapes.Shape.Changed"/> event of the
            contained <see cref="P:DigitalRune.Physics.RigidBody.Shape"/>. Therefore, a <see cref="T:DigitalRune.Geometry.Shapes.Shape"/> 
            will have an indirect reference to the <see cref="T:DigitalRune.Geometry.IGeometricObject"/>. This is no problem if
            the geometric object exclusively owns the shape. However, this could lead to problems ("life
            extension bugs" a.k.a. "memory leaks") when multiple geometric objects share the same shape:
            One geometric object is no longer used but it cannot be collected by the garbage collector
            because the shape still holds a reference to the object.
            </para>
            <para>
            Therefore, when <see cref="T:DigitalRune.Geometry.Shapes.Shape"/>s are shared between multiple 
            <see cref="T:DigitalRune.Geometry.IGeometricObject"/>s: Always set the property <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> to 
            <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/> when the <see cref="T:DigitalRune.Geometry.IGeometricObject"/> 
            is no longer used. <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/> is a special 
            immutable shape that never raises any <see cref="E:DigitalRune.Geometry.Shapes.Shape.Changed"/> 
            events. Setting <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> to <see cref="F:DigitalRune.Geometry.Shapes.Shape.Empty"/> 
            ensures that the internal event handlers are unregistered and the object can be 
            garbage-collected properly.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.Scale">
            <summary>
            Gets or sets the scale.
            </summary>
            <value>
            The scale factors for the dimensions x, y and z. The default value is (1, 1, 1), which means
            "no scaling".
            </value>
            <remarks>
            <para>
            This value is a scale factor that scales the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> of this geometric object.
            The scale can even be negative to mirror an object.
            </para>
            <para>
            Changing this value does not actually change any values in the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> instance.
            Collision algorithms and anyone who uses this geometric object must use the shape and apply
            the scale factor as appropriate. The scale is automatically applied in the property
            <see cref="P:DigitalRune.Physics.RigidBody.Aabb"/>.
            </para>
            <para>
            Changing this property raises the <see cref="E:DigitalRune.Physics.RigidBody.ShapeChanged"/> event.
            </para>
            </remarks>
        </member>
        <member name="E:DigitalRune.Physics.RigidBody.PoseChanged">
            <summary>
            Occurs when the pose was changed.
            </summary>
        </member>
        <member name="E:DigitalRune.Physics.RigidBody.ShapeChanged">
            <summary>
            Occurs when the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> or <see cref="P:DigitalRune.Physics.RigidBody.Scale"/> was changed.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.OnPoseChanged(System.EventArgs)">
            <summary>
            Raises the <see cref="E:DigitalRune.Physics.RigidBody.PoseChanged"/> event.
            </summary>
            <param name="eventArgs">
            <see cref="T:System.EventArgs"/> object that provides the arguments for the event.
            </param>
            <remarks>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.RigidBody.OnPoseChanged(System.EventArgs)"/> 
            in a derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.RigidBody.OnPoseChanged(System.EventArgs)"/> 
            method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.OnShapeChanged(System.Object,DigitalRune.Geometry.Shapes.ShapeChangedEventArgs)">
            <summary>
            Called when the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> property has changed.
            </summary>
            <param name="sender">The sender.</param>
            <param name="eventArgs">
            The <see cref="T:DigitalRune.Geometry.Shapes.ShapeChangedEventArgs"/> instance containing the event data.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.OnShapeChanged(DigitalRune.Geometry.Shapes.ShapeChangedEventArgs)">
            <summary>
            Raises the <see cref="E:DigitalRune.Physics.RigidBody.ShapeChanged"/> event.
            </summary>
            <param name="eventArgs">
            <see cref="T:DigitalRune.Geometry.Shapes.ShapeChangedEventArgs"/> object that provides the arguments for the event.
            </param>
            <remarks>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.RigidBody.OnShapeChanged(DigitalRune.Geometry.Shapes.ShapeChangedEventArgs)"/> 
            in a derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.RigidBody.OnShapeChanged(DigitalRune.Geometry.Shapes.ShapeChangedEventArgs)"/> 
            method so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdatePoseCenterOfMass">
            <summary>
            Updates <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> from <see cref="P:DigitalRune.Physics.RigidBody.Pose"/>.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdatePose">
            <summary>
            Updates <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> from <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/>.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.MassFrame">
            <summary>
            Gets or sets the mass frame which defines the mass properties of this body.
            </summary>
            <value>
            The mass frame. Per default a mass frame is computed for the current <see cref="P:DigitalRune.Physics.RigidBody.Shape"/>,
            <see cref="P:DigitalRune.Physics.RigidBody.Scale"/> and a density of 1000.
            </value>
            <remarks>
            If the mass frame is modified, related properties, like <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> are
            updated automatically.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.MassInverse">
            <summary>
            Gets the effective inverse mass.
            </summary>
            <value>The effective inverse mass.</value>
            <remarks>
            <para>
            This property stores the inverse of the mass defined in the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>. This
            value is modified by other simulation properties. For example, if the body is 
            <see cref="F:DigitalRune.Physics.MotionType.Static"/> or <see cref="F:DigitalRune.Physics.MotionType.Kinematic"/> this
            value is set to 0.
            </para>
            <para>
            This property is mostly only of interest if you are implementing new 
            <see cref="T:DigitalRune.Physics.Constraints.Constraint"/>s.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.InertiaWorld">
            <summary>
            Gets the world space inertia matrix.
            </summary>
            <value>The world space inertia matrix.</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.InertiaInverseWorld">
            <summary>
            Gets the effective inverse inertia.
            </summary>
            <value>The effective inverse inertia.</value>
            <remarks>
            <para>
            This property stores the inverse of the inertia matrix (defined in <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>)
            in world space. This value is modified by other simulation properties. For example, if the
            body is <see cref="F:DigitalRune.Physics.MotionType.Static"/> or <see cref="F:DigitalRune.Physics.MotionType.Kinematic"/>
            this value is set to 0. 
            </para>
            <para>
            This property is mostly only of interest if you are implementing new 
            <see cref="T:DigitalRune.Physics.Constraints.Constraint"/>s.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.AutoUpdateMass">
            <summary>
            Gets or sets a value indicating whether the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> is automatically updated
            if the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> or <see cref="P:DigitalRune.Physics.RigidBody.Scale"/> of this body is changed.
            </summary>
            <value>
            <see langword="true"/> if the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> is automatically updated when the 
            <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> or <see cref="P:DigitalRune.Physics.RigidBody.Scale"/> is changed; otherwise, <see langword="false"/>.
            The default value is <see langword="true"/>.
            </value>
            <remarks>
            <para>
            If the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> or the <see cref="P:DigitalRune.Physics.RigidBody.Scale"/> of a rigid body is changed, the mass
            properties should usually change too. If this property is <see langword="true"/>
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> is automatically updated. If the current <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> was
            computed for a certain density (see <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndDensity(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/>),
            the new <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> will use the same density. If the current 
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> was computed for a certain total target mass (see 
            <see cref="M:DigitalRune.Physics.MassFrame.FromShapeAndMass(DigitalRune.Geometry.Shapes.Shape,DigitalRune.Mathematics.Algebra.Vector3F,System.Single,System.Single,System.Int32)"/>), the new <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> will use
            the same total target mass. (If the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> is not set manually, rigid
            bodies use an automatic computed mass for a target density of 1000.) If this property is 
            <see langword="false"/>, the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/> is not adjusted when the shape or scale
            is changed.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.LockRotationX">
            <summary>
            Gets or sets a value indicating whether the body can rotate around its local mass frame 
            x-axis.
            </summary>
            <value>
            <see langword="true"/> if rotations around the local x-axis (of the mass frame) are locked; 
            otherwise, <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            <para>
            If this flag is set, forces and collision impacts will not rotate the body around the locked
            axis. The body can still be rotated by setting an angular velocity or by changing the 
            <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> (<see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/>) of the body directly.
            </para>
            <para>
            The lock axis refers to an axis of the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>. If 
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>.<see cref="P:DigitalRune.Physics.MassFrame.Pose"/> does not contain a rotation,
            the lock axis is equal to the local coordinate axis of the body. If
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>.<see cref="P:DigitalRune.Physics.MassFrame.Pose"/> contains a rotation, the lock
            axis is not identical to the local space axis of the body. In other words: The lock axes are
            the local axes of the <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> and not the local axes of the 
            <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> of this body.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.LockRotationY">
            <summary>
            Gets or sets a value indicating whether the body can rotate around its local mass frame 
            y-axis.
            </summary>
            <value>
            <see langword="true"/> if rotations around the local y-axis (of the mass frame) are locked; 
            otherwise, <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            <para>
            If this flag is set, forces and collision impacts will not rotate the body around the locked
            axis. The body can still be rotated by setting an angular velocity or by changing the 
            <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> (<see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/>) of the body directly.
            </para>
            <para>
            The lock axis refers to an axis of the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>. If 
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>.<see cref="P:DigitalRune.Physics.MassFrame.Pose"/> does not contain a rotation,
            the lock axis is equal to the local coordinate axis of the body. If
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>.<see cref="P:DigitalRune.Physics.MassFrame.Pose"/> contains a rotation, the lock
            axis is not identical to the local space axis of the body. In other words: The lock axes are
            the local axes of the <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> and not the local axes of the 
            <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> of this body.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.LockRotationZ">
            <summary>
            Gets or sets a value indicating whether the body can rotate around its local mass frame 
            z-axis.
            </summary>
            <value>
            <see langword="true"/> if rotations around the local z-axis (of the mass frame) are locked; 
            otherwise, <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            <para>
            If this flag is set, forces and collision impacts will not rotate the body around the locked
            axis. The body can still be rotated by setting an angular velocity or by changing the 
            <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> (<see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/>) of the body directly.
            </para>
            <para>
            The lock axis refers to an axis of the <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>. If 
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>.<see cref="P:DigitalRune.Physics.MassFrame.Pose"/> does not contain a rotation,
            the lock axis is equal to the local coordinate axis of the body. If
            <see cref="P:DigitalRune.Physics.RigidBody.MassFrame"/>.<see cref="P:DigitalRune.Physics.MassFrame.Pose"/> contains a rotation, the lock
            axis is not identical to the local space axis of the body. In other words: The lock axes are
            the local axes of the <see cref="P:DigitalRune.Physics.RigidBody.PoseCenterOfMass"/> and not the local axes of the 
            <see cref="P:DigitalRune.Physics.RigidBody.Pose"/> of this body.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdateMassFrame">
            <summary>
            Updates the mass frame for a new shape and scale.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdateInverseMass">
            <summary>
            Updates the cached inverse mass and inertia.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.CanSleep">
            <summary>
            Gets or sets a value indicating whether this body can sleep.
            </summary>
            <value>
            <see langword="true"/> if this rigid body can sleep; otherwise, <see langword="false"/>. 
            The default is <see langword="true"/>.
            </value>
            <remarks>
            Normally, all rigid bodies can sleep (see also <see cref="T:DigitalRune.Physics.Settings.SleepingSettings"/>). For 
            critical bodies sleeping can be disabled, e.g. for rigid bodies of the player character. If 
            <see cref="P:DigitalRune.Physics.RigidBody.CanSleep"/> is <see langword="false"/>, this body will always be awake and
            actively simulated.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.IsSleepingCandidate">
            <summary>
            Gets a value indicating whether the rigid body is a sleeping candidate, i.e. it is already 
            sleeping or will be sleeping in the next time step.
            </summary>
            <value>
            <see langword="true"/> if this rigid body is a sleeping candidate; otherwise, 
            <see langword="false"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.IsSleeping">
            <summary>
            Gets a value indicating whether this rigid body is sleeping.
            </summary>
            <value>
            <see langword="true"/> if this instance is sleeping; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.IslandTouchesImmovable">
            <summary>
            Gets or sets a value indicating whether the simulation island touches a static or resting
            kinematic body. (Experimental)
            </summary>
            <value>
            <see langword="true"/> if the simulation island touches a static or resting kinematic body; 
            otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.DeferSleep(System.Single)">
            <summary>
            Makes sure the body is not sleeping for the given duration.
            </summary>
            <param name="duration">The duration.</param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.Sleep">
            <summary>
            Deactivates this rigid body. 
            </summary>
            <remarks>
            The simulation will automatically put rigid bodies to sleep if they do not move for some
            time. This method can be called manually if rigid bodies are already initialized in a stable
            resting configuration. For example, if a stack of bodies is initialized in a game, 
            <see cref="M:DigitalRune.Physics.RigidBody.Sleep"/> can be called for all bodies in the stack after the first 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/>. The bodies will wake up when other 
            objects interact with the stacked bodies. (Note: 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> needs to be called at least once to detect
            all collision and initialize all constraints. After the 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> the bodies can be put to sleep.)
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.WakeUp">
            <summary>
            Wakes the rigid body up from sleeping.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdateSleeping(System.Single)">
            <summary>
            Updates the sleeping state. Is called in <see cref="M:DigitalRune.Physics.RigidBody.UpdateVelocity(System.Single)"/>.
            </summary>
            <param name="deltaTime">The time step.</param>
        </member>
        <member name="F:DigitalRune.Physics.RigidBody.TimeOfImpact">
            <summary>
            The time of impact. Used during motion clamping.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.CcdEnabled">
            <summary>
            Gets or sets a value indicating whether Continuous Collision Detection (CCD) is enabled.
            </summary>
            <value>
            <see langword="true"/> if CCD is enabled; otherwise, <see langword="false"/>.
            The default is <see langword="false"/>.
            </value>
            <remarks>
            See also <see cref="T:DigitalRune.Physics.Settings.MotionSettings"/>. CCD can be used for small fast moving objects to
            detect all collisions, e.g. for bullets. The simulation will only perform CCD for pairs
            of rigid bodies where <see cref="P:DigitalRune.Physics.RigidBody.CcdEnabled"/> is set for one of the bodies. If CCD is not
            enabled for this body, it can happen that this body moves through other bodies and the 
            collision is not detected - this problem only occurs for small/thin objects and fast moving 
            objects.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.IsCcdActive">
            <summary>
            Gets or sets a value indicating whether CCD should be performed for this body in the 
            current time step.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.LinearVelocity">
            <summary>
            Gets or sets the linear velocity of this body in world space.
            </summary>
            <value>The linear velocity in world space.</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.AngularVelocity">
            <summary>
            Gets or sets the angular velocity about the center of mass in world space.
            </summary>
            <value>The angular velocity in world space.</value>
        </member>
        <member name="F:DigitalRune.Physics.RigidBody.LinearCorrectionVelocity">
            <summary>
            Gets or sets the linear correction velocity.
            </summary>
            <value>The linear correction velocity.</value>
            <remarks>
            This is used for Split Impulses. Also known as push impulses, flash impulses, first order
            world impulses, etc. This velocity is set to 0 at the end of each time step.
            </remarks>
        </member>
        <member name="F:DigitalRune.Physics.RigidBody.AngularCorrectionVelocity">
            <summary>
            Gets or sets the angular correction velocity.
            </summary>
            <value>The angular correction velocity.</value>
            <remarks>
            This is used for Split Impulses. Also known as push impulses, flash impulses, first order
            world impulses, etc. This velocity is set to 0 at the end of each time step.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.RotationalEnergy">
            <summary>
            Gets the rotational kinetic energy.
            </summary>
            <value>The rotational kinetic energy.</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.TranslationalEnergy">
            <summary>
            Gets the translational kinetic energy.
            </summary>
            <value>The translational kinetic energy.</value>
        </member>
        <member name="P:DigitalRune.Physics.RigidBody.KineticEnergy">
            <summary>
            Gets the kinetic energy.
            </summary>
            <value>The kinetic energy.</value>
            <remarks>
            The kinetic energy is the sum of the <see cref="P:DigitalRune.Physics.RigidBody.TranslationalEnergy"/> and the
            <see cref="P:DigitalRune.Physics.RigidBody.RotationalEnergy"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.ApplyImpulse(DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies an impulse at a given position.
            </summary>
            <param name="impulseWorld">The impulse in world space.</param>
            <param name="positionWorld">
            The position where the impulse is applied in world space.
            </param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.ApplyLinearImpulse(DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a linear impulse at the center of mass
            </summary>
            <param name="impulseWorld">The impulse in world space.</param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.ApplyAngularImpulse(DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies an angular impulse at the center of mass
            </summary>
            <param name="impulseWorld">The impulse in world space.</param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.ApplyCorrectionImpulse(DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Applies a correction impulse at a given position.
            </summary>
            <param name="impulseWorld">The impulse in world space.</param>
            <param name="positionWorld">
            The position where the impulse is applied in world space.
            </param>
            <remarks>
            Correction impulses are also known as push impulses, flash impulses, first order world 
            impulses etc. This is similar to <see cref="M:DigitalRune.Physics.RigidBody.ApplyImpulse(DigitalRune.Mathematics.Algebra.Vector3F,DigitalRune.Mathematics.Algebra.Vector3F)"/> but only the correction
            velocities (<see cref="F:DigitalRune.Physics.RigidBody.LinearCorrectionVelocity"/> and 
            <see cref="F:DigitalRune.Physics.RigidBody.AngularCorrectionVelocity"/>) are changed.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.GetVelocityOfWorldPoint(DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Gets the velocity of a point on the rigid body.
            </summary>
            <param name="positionWorld">The position of the point in world space.</param>
            <returns>
            The velocity of the point on the rigid body in world space.
            </returns>
            <remarks>
            This method computes the velocity of a point that is fixed on the moving body.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.GetVelocityOfLocalPoint(DigitalRune.Mathematics.Algebra.Vector3F)">
            <summary>
            Gets the velocity of a point on the rigid body.
            </summary>
            <param name="positionLocal">
            The position of the point in the local space of the rigid body.
            </param>
            <returns>
            The velocity of the point on the rigid body in world space.
            </returns>
            <remarks>
            This method computes the velocity of a point that is fixed on the moving body.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdateVelocity(System.Single)">
            <summary>
            Updates the velocities using numerical integration.
            </summary>
            <param name="deltaTime">The time step.</param>
        </member>
        <member name="M:DigitalRune.Physics.RigidBody.UpdatePose(System.Single)">
            <summary>
            Updates the pose using numerical integration.
            </summary>
            <param name="deltaTime">The time step.</param>
        </member>
        <member name="T:DigitalRune.Physics.RigidBodyCollection">
            <summary>
            Stores the <see cref="T:DigitalRune.Physics.RigidBody"/> objects of a simulation.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBodyCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.RigidBodyCollection"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.RigidBodyCollection.InsertItem(System.Int32,DigitalRune.Physics.RigidBody)">
            <inheritdoc/>
        </member>
        <member name="M:DigitalRune.Physics.RigidBodyCollection.SetItem(System.Int32,DigitalRune.Physics.RigidBody)">
            <inheritdoc/>
        </member>
        <member name="T:DigitalRune.Physics.Settings.ConstraintSettings">
            <summary>
            Defines constraint-related simulation settings.
            </summary>
            <remarks>
            <para>
            <strong>Allowed Errors:</strong> For constraints small errors are allowed (e.g. small
            penetrations of rigid bodies). This improves the stability of the simulation. 
            <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/>s can have an <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.AllowedPenetration"/>. Other 
            constraints can have an <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.AllowedLinearDeviation"/> and an 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.AllowedAngularDeviation"/>. The allowed errors should be significantly larger than 
            0, but so small that the visual errors in the application are acceptable.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.AllowedPenetration">
            <summary>
            Gets or sets the allowed penetration of <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/>s.
            </summary>
            <value>The maximal allowed penetration. The default is 0.01.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.AllowedLinearDeviation">
            <summary>
            Gets or sets the allowed linear error of constraints.
            </summary>
            <value>The absolute allowed linear error of constraints. The default is 0.01.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.AllowedAngularDeviation">
            <summary>
            Gets or sets the allowed angular error of constraints.
            </summary>
            <value>The absolute allowed angular error of constraints. The default is 0.01.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.NumberOfConstraintIterations">
            <summary>
            Gets or sets the number of constraint iterations per time step.
            </summary>
            <value>The number of constraint iterations. Must be positive. The default value is 10.
            </value>
            <remarks>
            The constraint solver uses an iterative algorithm. Increasing the number of iterations
            improves the simulation stability but makes the simulation slower.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative or 0.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.MinConstraintImpulse">
            <summary>
            Gets or sets the minimal constraint impulse.
            </summary>
            <value>
            The minimal constraint impulse in the range [0, ∞[. The default value is 0.000001.
            </value>
            <remarks>
            If a all constraint impulses in a <see cref="T:DigitalRune.Physics.SimulationIsland"/> are below this limit,
            the constraint solving for this island is aborted. Setting a large value improves 
            simulation performance but reduces the stability of the simulation.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.RandomizeConstraints">
            <summary>
            Gets or sets a value indicating whether constraints are randomly reordered during
            constraint solving.
            </summary>
            <value>
            <see langword="true"/> if constraints are randomly reordered during constraint solving; 
            otherwise, <see langword="false"/>. The default value is <see langword="true"/>.
            </value>
            <remarks>
            <para>
            When the constraints of a simulation island are solved, the stability can be greatly
            improved by randomly reordering constraints (internally in the solver). This stability
            improvement is very visible in stacks of bodies. 
            </para>
            <para>
            Disabling this flag increases the simulation performance at the cost of stability.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.StackingFactor">
            <summary>
            Gets or sets the stacking optimization factor. (Experimental)
            </summary>
            <value>
            The stacking optimization factor in the range [0, ∞[. The default value is 0.
            </value>
            <remarks>
            <para>
            Stacking objects is difficult for the simulation - especially if the 
            <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/> is large or the 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.NumberOfConstraintIterations"/> is low. The stacking optimization is a trick to
            improve the stability of stacking by reducing the gravity acceleration of objects in a
            stack. If <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.StackingFactor"/> is 0, the optimization is disabled. Non-zero
            values enable the stacking optimization. Higher values use a more aggressive optimization.
            Recommended values are 0 - 10.
            </para>
            <para>
            This stacking optimization is independent from the <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.StackingTolerance"/>
            optimization.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.StackingTolerance">
            <summary>
            Gets or sets the stacking optimization tolerance. (Experimental)
            </summary>
            <value>
            The stacking optimization tolerance in the range [0, 1]. The default value is 0.1.
            </value>
            <remarks>
            <para>
            Stacking objects is difficult for the simulation - especially if the 
            <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/> is large or the 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.NumberOfConstraintIterations"/> is low. The stacking optimization is a trick to
            improve the stability of stacking by stabilizing contacts. A non-zero value improves the
            stability of high stacks or walls and it improves the simulation performance when there are 
            many contacts.
            </para>
            <para>
            Use a value of 0 to disable this optimization. This will make stacks less stable and 
            the simulation will actually be a bit slower. But any unnatural behaviors that could be
            caused by this stacking optimization are removed.
            </para>
            <para>
            Use a value of 1 to fully enable this optimization. This will make stakes more stable and 
            the simulation performance is improved. In very rare cases, the stacking optimization can 
            cause unnatural behavior. 
            </para>
            <para>
            Any value between 0 and 1 can be used. Already very small values (0.05 - 0.1) are enough to
            greatly improve the stability of stacks.
            </para>
            <para>
            This stacking optimization is independent from the <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.StackingFactor"/>
            optimization.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is less than 0 or greater than 1.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.ContactErrorReduction">
            <summary>
            Gets or sets the contact error reduction parameter.
            </summary>
            <value>
            The contact error reduction parameter in the range [0, 1]. The default value is 0.2.
            </value>
            <remarks>
            This value defines the speed by which penetration errors of contact constraints are 
            removed. If the value is 0, penetration errors are not corrected. If the value is set to 1,
            the simulation tries to remove 100% of the error in each time step - this is not stable and
            smaller values are recommended.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.RestitutionThreshold">
            <summary>
            Gets or sets the restitution threshold.
            </summary>
            <value>The restitution threshold in the range [0, 1]. The default value 0.05.</value>
            <remarks>
            Restitution is also called bounciness. Rigid body materials (see <see cref="T:DigitalRune.Physics.Materials.IMaterial"/>)
            define a coefficient of restitution for each body. If two bodies collide, a combined
            coefficient of restitution is computed to determine if the bodies will bounce or if the
            collision will be inelastic. To increase stability the simulation will clamp restitution
            values below <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.RestitutionThreshold"/> to 0. Increasing this value improves the
            simulation stability but reduces bounciness of objects with small bounciness values.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.RestingVelocityLimit">
            <summary>
            Gets or sets the resting velocity limit.
            </summary>
            <value>The resting velocity limit.</value>
            <remarks>
            Rigid bodies will not bounce off of each other if their relative collision velocity is less
            than <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.RestingVelocityLimit"/>. Increasing this value improves simulation stability
            and reduces the bounciness of slow objects.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.BaumgarteRatio">
            <summary>
            Gets or sets the Baumgarte error correction ratio. (Experimental)
            </summary>
            <value>The Baumgarte ratio in the range [0, 1]. The default is 1.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative or greater than 1.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.MaxErrorCorrectionVelocity">
            <summary>
            Gets or sets the maximal error correction velocity for general constraint errors.
            </summary>
            <value>
            The maximal error correction velocity. Must be greater than or equal to 0. The default value 
            is 100.
            </value>
            <remarks>
            The simulation will move bodies to remove constraint errors (e.g. interpenetrations of 
            rigid bodies or violated joint limits). The error correction velocities for constraint 
            errors are cut off above <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MaxErrorCorrectionVelocity"/>. For penetration errors 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MaxPenetrationCorrectionVelocity"/> is used, not 
            <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MaxErrorCorrectionVelocity"/>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.ConstraintSettings.MaxPenetrationCorrectionVelocity">
            <summary>
            Gets or sets the maximal error correction velocity for correcting rigid body 
            interpenetrations.
            </summary>
            <value>
            The maximal error correction velocity for penetration errors. Must be greater than or equal 
            to 0. The default value is 2.
            </value>
            <remarks>
            The simulation will move bodies to remove constraint errors (e.g. interpenetrations of 
            rigid bodies or violated joint limits). The error correction velocities for penetration
            errors are cut off above <see cref="P:DigitalRune.Physics.Settings.ConstraintSettings.MaxPenetrationCorrectionVelocity"/>. 
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Settings.ConstraintSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Settings.ConstraintSettings"/> class.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Settings.MotionSettings">
            <summary>
            Defines motion-related simulation settings.
            </summary>
            <remarks>
            <para>
            <strong>Continuous Collision Detection (CCD):</strong> The purpose of CCD is to detect 
            collisions of fast moving objects that would otherwise be missed. The opposite of CCD is
            Discrete Collision Detection which only checks for collision at one position for each frame.
            If the objects move, collisions between the old position and new position are not detected.
            Example: A bullet (e.g. a small sphere shape) is fired at a wall. In one frame the bullet is 
            in front of the wall. In the next frame the bullet is behind the wall without touching it. If 
            this happens Discrete Collision Detection does not report a collision. This problem is known
            as "tunneling". CCD is more expensive but detects all collisions. (CCD has some limitations, 
            for example, some collisions that occur because of rotational movement can be missed. But 
            such limitations are hardly noticeable).
            </para>
            <para>
            <strong>Motion Clamping:</strong> If CCD is enabled, the <see cref="T:DigitalRune.Physics.Simulation"/> uses a
            strategy called "Motion Clamping" to deal with fast moving objects: In each time step fast
            moving objects are only moved to their first time of impact, so that a collision is detected
            in the next time step. This is obviously not physically correct because the fast moving object
            moves a smaller distance than it should - but for fast moving objects, like bullets, it is
            more important to detect all collisions and it is usually not noticeable when the movement 
            distance is clamped.
            </para>
            <para>
            <strong>CCD Settings:</strong> CCD can be globally enabled or disabled with 
            <see cref="P:DigitalRune.Physics.Settings.MotionSettings.CcdEnabled"/>. CCD is only performed for rigid bodies that have a velocity beyond 
            <see cref="P:DigitalRune.Physics.Settings.MotionSettings.CcdVelocityThreshold"/> and if <see cref="P:DigitalRune.Physics.RigidBody.CcdEnabled"/> is set. Further,
            a filter predicate method (<see cref="P:DigitalRune.Physics.Settings.MotionSettings.CcdFilter"/>) can be set. CCD is only used if no 
            predicate method is set or if the predicate method returns <see langword="true"/> for a pair
            of rigid bodies.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.MotionSettings.CcdEnabled">
            <summary>
            Gets or sets a value indicating whether Continuous Collision Detection (CCD) is enabled.
            </summary>
            <value>
            <see langword="true"/> if CCD is enabled; otherwise, <see langword="false"/>.
            The default is <see langword="true"/>.
            </value>
            <remarks>
            <para>
            By setting this property to <see langword="false"/> the Continuous Collision Detection can 
            be globally disabled in a physics simulation. 
            </para>
            <para>
            CCD can also be enabled/disabled per rigid body (see 
            <see cref="T:DigitalRune.Physics.RigidBody"/>.<see cref="P:DigitalRune.Physics.RigidBody.CcdEnabled"/>); or for pairs of rigid bodies 
            by using the <see cref="P:DigitalRune.Physics.Settings.MotionSettings.CcdFilter"/> predicate.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.MotionSettings.CcdFilter">
            <summary>
            Gets or sets a predicate method that defines whether CCD is enabled between a pair of rigid 
            bodies.
            </summary>
            <value>
            A method that returns <see langword="true"/> if CCD should be used. If this method returns 
            <see langword="false"/>, CCD is not used for the given pair of bodies. If this value is 
            <see langword="null"/>, CCD is enabled for all pairs. The default is 
            <see langword="null"/>.
            </value>
            <remarks>
            <para>
            The method does not need to check whether parameters are <see langword="null"/>. It is 
            guaranteed that the method is never called with <see langword="null"/> parameters.
            </para>
            <para>
            <strong>Thread-safety:</strong> This method may be called concurrently from different
            threads. It must be safe for threading!
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.MotionSettings.CcdVelocityThreshold">
            <summary>
            Gets or sets the velocity threshold for Continuous Collision Detection (CCD).
            </summary>
            <value>
            The CCD velocity threshold. The default value is 5.
            </value>
            <remarks>
            Continuous Collision Detection (CCD) is only performed for rigid bodies that are faster than
            this velocity limit.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.MotionSettings.MaxLinearVelocity">
            <summary>
            Gets or sets the maximal linear velocity.
            </summary>
            <value>The maximal linear velocity. The default is 100.</value>
            <remarks>
            All linear velocities are clamped to this limit because high velocities can lead to 
            unstable simulations.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.MotionSettings.MaxAngularVelocity">
            <summary>
            Gets or sets the maximal angular velocity.
            </summary>
            <value>
            The maximal angular velocity. The default is 100.
            </value>
            <remarks>
            All angular velocities are clamped to this limit because high velocities can lead to 
            unstable simulations.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.MotionSettings.RemoveBodiesOutsideWorld">
            <summary>
            Gets or sets a value indicating whether bodies that leave the simulation are automatically
            removed.
            </summary>
            <value>
            <see langword="true"/> if bodies outside the simulation world are removed; otherwise, 
            <see langword="false"/>. The default value is <see langword="true"/>.
            </value>
            <remarks>
            <para>
            The area of a simulation is defined by <see cref="F:DigitalRune.Physics.Simulation.World"/>. If this flag is set
            to <see langword="true"/>, bodies that leave the axis-aligned bounding box of this area are
            automatically removed from the simulation. Bodies are also removed if a value in their 
            pose is NaN.
            </para>
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Settings.MotionSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Settings.MotionSettings"/> class.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Settings.NamespaceDoc">
            <summary>
            The <see cref="N:DigitalRune.Physics.Settings"/> namespace contains the physics simulation
            settings.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Settings.SimulationSettings">
            <summary>
            Defines simulation settings that control the physics simulation.
            </summary>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.Constraints">
            <summary>
            Gets or sets the constraint-related simulation settings.
            </summary>
            <value>The constraint settings.</value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.Motion">
            <summary>
            Gets or sets the motion-related simulation settings.
            </summary>
            <value>The motion settings.</value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.Sleeping">
            <summary>
            Gets or sets the sleeping-related simulation settings.
            </summary>
            <value>The sleeping settings.</value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.EnableMultithreading">
            <summary>
            Gets or sets a value indicating whether multithreading is enabled.
            </summary>
            <value>
            <see langword="true"/> if multithreading is enabled; otherwise, <see langword="false"/>. The
            default value is <see langword="true"/> if the current system has more than one CPU cores.
            </value>
            <remarks>
            <para>
            When multithreading is enabled the simulation will distribute the workload across multiple 
            processors (CPU cores) to improve the performance. 
            </para>
            <para>
            Multithreading adds an additional overhead, therefore it should only be enabled if the 
            current system has more than one CPU core and if the other cores are not fully utilized by
            the application. Multithreading should be disabled if the system has only one CPU core or
            if all other CPU cores are busy. In some cases it might be necessary to run a benchmark of
            the application and compare the performance with and without multithreading to decide
            whether multithreading should be enabled or not.
            </para>
            <para>
            The simulation internally uses the class <see cref="T:DigitalRune.Threading.Parallel"/> for parallelization.
            <see cref="T:DigitalRune.Threading.Parallel"/> is a static class that defines how many worker threads are created, 
            how the workload is distributed among the worker threads and more. (See 
            <see cref="T:DigitalRune.Threading.Parallel"/> to find out more on how to configure parallelization.)
            </para>
            </remarks>
            <seealso cref="T:DigitalRune.Threading.Parallel"/>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.SynchronizeCollisionDomain">
            <summary>
            Gets or sets a value indicating whether the collision domain is kept up-to-date.
            </summary>
            <value>
            <see langword="true"/> if collision domain is kept up-to-date; otherwise, 
            <see langword="false"/>. The default value is <see langword="false"/>.
            </value>
            <remarks>
            <para>
            The simulation updates the internal collision domain (see 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/>) only if necessary. In 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> the collision domain is updated to compute the 
            new contacts at the beginning of each time step. Then the new positions and orientations of 
            the simulation objects are computed. At the end of <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> 
            the contact information of the collision domain is not up-to-date because the simulation 
            objects have moved.
            </para>
            <para>
            By setting <see cref="P:DigitalRune.Physics.Settings.SimulationSettings.SynchronizeCollisionDomain"/> to <see langword="true"/> the 
            <see cref="T:DigitalRune.Physics.Simulation"/> explicitly updates the collision domain at the end of 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> to ensure that the contact information is valid. 
            This additional update costs a bit of performance, therefore the property 
            <see cref="P:DigitalRune.Physics.Settings.SimulationSettings.SynchronizeCollisionDomain"/> should only be set if other parts of the 
            application need to access the contact information of the collision domain.
            </para>
            <para>
            Alternatively, the user can explicitly update the collision domain by calling:
            <code lang="csharp">
            <![CDATA[
            // Ensure that the contact information is up-to-date.
            simulation.CollisionDomain.Update(0);
            ]]>
            </code>
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.Timing">
            <summary>
            Gets or sets the timing-related simulation settings.
            </summary>
            <value>The timing settings.</value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SimulationSettings.MaterialPropertyCombiner">
            <summary>
            Gets or sets the material property combiner.
            </summary>
            <value>
            The material property combiner. The default is a new instance of type 
            <see cref="T:DigitalRune.Physics.Materials.MaterialPropertyCombiner"/>.
            </value>
            <remarks>
            The material combiner is used to compute material settings of touching bodies.
            See <see cref="T:DigitalRune.Physics.Materials.IMaterialPropertyCombiner"/> for more information. This object can 
            be replaced to use a custom material combination strategy.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Settings.SimulationSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Settings.SimulationSettings"/> class.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Settings.SleepingSettings">
            <summary>
            Defines sleeping-related simulation settings.
            </summary>
            <remarks>
            <para>
            <strong>Sleeping:</strong> Sleeping is also known as deactivation: Rigid bodies that do not
            move for a certain amount of time are deactivated ("put to sleep"). The simulation will do
            less work for sleeping bodies which results in a performance gain. Bodies are also put to
            sleep if they have a very low velocity for a certain period. For sleeping bodies the velocity
            is clamped to zero, which means that sleeping also improves the simulation stability by
            removing small (possible erroneous) velocities.
            </para>
            <para>
            Rigid bodies will start to sleep if their <see cref="P:DigitalRune.Physics.RigidBody.LinearVelocity"/> is below
            <see cref="P:DigitalRune.Physics.Settings.SleepingSettings.LinearVelocityThreshold"/> and their <see cref="P:DigitalRune.Physics.RigidBody.AngularVelocity"/> is
            below <see cref="P:DigitalRune.Physics.Settings.SleepingSettings.AngularVelocityThreshold"/> for a time larger than 
            <see cref="P:DigitalRune.Physics.Settings.SleepingSettings.TimeThreshold"/>.
            </para>
            <para>
            The <see cref="T:DigitalRune.Physics.RigidBody"/> class also has several sleep related methods and properties, see
            <see cref="P:DigitalRune.Physics.RigidBody.CanSleep"/>, <see cref="P:DigitalRune.Physics.RigidBody.IsSleeping"/>, 
            <see cref="M:DigitalRune.Physics.RigidBody.Sleep"/> and <see cref="M:DigitalRune.Physics.RigidBody.WakeUp"/>.
            </para>
            <para>
            <strong>Simulation Islands:</strong> A <see cref="T:DigitalRune.Physics.SimulationIsland"/> can only sleep as a
            whole. It is not possible that some bodies in an island are sleeping and others are awake. If
            one object is awake all objects are awake because the movement of the awake body can propagate
            to the other bodies. In unfortunate configurations a jittering body can keep a whole island
            awake. 
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SleepingSettings.LinearVelocityThreshold">
            <summary>
            Gets or sets the linear sleeping velocity threshold.
            </summary>
            <value>
            The linear velocity threshold. The default is 0.4.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SleepingSettings.AngularVelocityThreshold">
            <summary>
            Gets or sets the angular sleeping velocity threshold.
            </summary>
            <value>
            The angular velocity threshold. The default is 0.5.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.SleepingSettings.TimeThreshold">
            <summary>
            Gets or sets the sleeping time threshold in seconds.
            </summary>
            <value>
            The time threshold in seconds. The default is 1 s.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Settings.SleepingSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Settings.SleepingSettings"/> class.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Settings.TimingSettings">
            <summary>
            Defines timing-related simulation settings.
            </summary>
            <remarks>
            <para>
            Each call of <see cref="T:DigitalRune.Physics.Simulation"/>.<see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> advances the 
            simulation state by a given time. The time by which the simulation should be advanced is 
            called a "time step". Internally the time step specified in the parameter of 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> is divided into sub time steps (internal time steps)
            of constant size. This constant size is <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/>. That means, if the user 
            calls <c>Simulation.Update(1.0f / 30.0f)</c> and <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/> is 1/60 (default),
            the simulation will perform to time steps with 1/60 s. 
            </para>
            <para>
            If the user calls <c>Simulation.Update(1.0f / 120.0f)</c>, the simulation will perform no 
            simulation update because the time step is less than <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/>. But the 
            time is not "lost". When the user calls <c>Simulation.Update(1.0f / 120.0f)</c> the next time,
            the simulation will make a single time step with 1/60 s. The simulation class makes sure that 
            all simulation updates use fixed time steps internally and that overall no simulation time is 
            lost.
            </para>
            <para>
            The number of time steps per <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> call is actually 
            limited by <see cref="P:DigitalRune.Physics.Settings.TimingSettings.MaxNumberOfSteps"/>. This is necessary to avoid a typical problem in 
            game physics: Example: There are too many physical objects in the game. One frame of the game
            took 0.016 ms to compute. The simulation is called with <c>Simulation.Update(0.016)</c> and it
            performs 1 time step internally. Because there are too many objects, this frame took 0.034 ms 
            to compute. In the next frame <c>Simulation.Update(0.034)</c> is called and the simulation 
            performs 2 time steps internally - which takes even more time... Each frame the simulation 
            must make more internal time steps to keep up with the elapsed time, and eventually the frame 
            rate of the game will go towards 0. To avoid this scenario the maximal number of allowed sub 
            time steps is limited - practically this means that time is lost and the simulation moves 
            objects in slow motion. Slow motion at a low frame rate is better than real-time at 0 frames 
            per second.
            </para>
            <para>
            <strong>Simulation Quality and Timing:</strong> Per default the simulation makes time steps 
            of 1/60 seconds (60 Hz). Increasing the time step size makes the simulation faster and less
            stable. Decreasing the time step size makes the simulation slower and more accurate and 
            stable - higher box stacks are possible, less jittering, less interpenetrations of objects.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep">
            <summary>
            Gets or sets the time step size for fixed time steps in seconds.
            </summary>
            <value>
            The time step size for fixed time steps in seconds. The default is 1/60 s (60 Hz).
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative or 0.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Settings.TimingSettings.MaxNumberOfSteps">
            <summary>
            Gets or sets the maximal number of sub-steps performed during one time step.
            </summary>
            <value>
            The maximal number of sub-steps performed during one time step. The default value is 
            <c>8</c>.
            </value>
            <remarks>
            This value implicitly defines the maximum size of a time step. A time step will be an
            integer multiple of <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/>, but maximal
            <see cref="P:DigitalRune.Physics.Settings.TimingSettings.MaxNumberOfSteps"/> ∙ <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/>. If <see cref="T:DigitalRune.Physics.Simulation"/>.
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> is called with a larger time step, time is lost.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative or 0.
            </exception>
        </member>
        <member name="M:DigitalRune.Physics.Settings.TimingSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Settings.TimingSettings"/> class.
            </summary>
        </member>
        <member name="T:DigitalRune.Physics.Simulation">
            <summary>
            Manages a physics simulation.
            </summary>
            <remarks>
            <para>
            The <see cref="T:DigitalRune.Physics.Simulation"/> owns collections of <see cref="P:DigitalRune.Physics.Simulation.RigidBodies"/>, 
            <see cref="P:DigitalRune.Physics.Simulation.Constraints"/> and <see cref="P:DigitalRune.Physics.Simulation.ForceEffects"/>. All <see cref="T:DigitalRune.Physics.RigidBody"/>, 
            <see cref="T:DigitalRune.Physics.Constraints.Constraint"/>, and <see cref="T:DigitalRune.Physics.ForceEffects.ForceEffect"/> objects need to be added to these
            collections. All objects in these collections take part in the simulation. Object that are not
            added to these collections are not simulated.
            </para>
            <para>
            <strong>Advancing the Simulation:</strong> To advance the simulation 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> must be called with the time span by which the simulation time 
            should advance. In <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> the simulation computes forces and moves the 
            objects to new positions. One step of the simulation is called a "time step". In some cases 
            the simulation will internally subdivide a time step into "sub time steps" or "internal time 
            steps". In most games the <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> will be called with 1/60 s (60 frames
            per second) and the simulation will make exactly one time step. See 
            <see cref="T:DigitalRune.Physics.Settings.TimingSettings"/> for more information regarding timing.
            </para>
            <para>
            <strong>Collision Detection:</strong> The <see cref="T:DigitalRune.Physics.Simulation"/> owns a 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/>. Each <see cref="T:DigitalRune.Physics.RigidBody"/> has a 
            <see cref="P:DigitalRune.Physics.RigidBody.CollisionObject"/> that represents the collision information of the body
            and is put into the collision domain. You are free to use the <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/> to
            perform collision queries (e.g. 
            <see cref="M:DigitalRune.Geometry.Collisions.CollisionDomain.GetContacts(DigitalRune.Geometry.Collisions.CollisionObject)"/>). You can also
            add custom <see cref="T:DigitalRune.Geometry.Collisions.CollisionObject"/>s to the collision domain. For example, you can add a
            collision object to check if rigid bodies or other collision objects enter a certain area. 
            </para>
            <para>
            The collision filter of the 
            <see cref="P:DigitalRune.Geometry.Collisions.CollisionDomain.CollisionDetection"/> is set to an instance of
            type <see cref="T:DigitalRune.Geometry.Collisions.CollisionFilter"/>. The filter rules in the <see cref="T:DigitalRune.Geometry.Collisions.CollisionFilter"/> can
            freely be changed as required by the application. The whole filter can be replaced too, but
            the new filter should implement the interface <see cref="T:DigitalRune.Geometry.Collisions.ICollisionFilter"/>. If the new 
            collision filter does not implement <see cref="T:DigitalRune.Geometry.Collisions.ICollisionFilter"/>, then automatic collision
            filtering for constraints does not work (see property <see cref="P:DigitalRune.Physics.Constraints.Constraint.CollisionEnabled"/>).
            Advanced physics modules like ragdoll physics and vehicle physics might also need a collision
            filter that implements <see cref="T:DigitalRune.Geometry.Collisions.ICollisionFilter"/>.
            </para>
            <para>
            The <see cref="P:DigitalRune.Geometry.Collisions.Contact.UserData"/> of <see cref="T:DigitalRune.Geometry.Collisions.Contact"/>s in this collision domain are used
            to store references to <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/>s. That means, <see cref="T:DigitalRune.Geometry.Collisions.Contact"/>.
            <see cref="P:DigitalRune.Geometry.Collisions.Contact.UserData"/> must not be changed.
            </para>
            <para>
            <strong>The "World" Rigid Body:</strong> The simulation owns one special rigid body that 
            represents the "world" of the simulation: <see cref="F:DigitalRune.Physics.Simulation.World"/>. This rigid body is not 
            contained in the <see cref="P:DigitalRune.Physics.Simulation.RigidBodies"/> collection and other bodies do not collide with 
            this body. This body is only used to define the space in which the simulation takes place.
            Rigid bodies that leave the space of this rigid body are automatically removed from the 
            simulation. Per default the <see cref="T:DigitalRune.Geometry.Shapes.Shape"/> of the <see cref="F:DigitalRune.Physics.Simulation.World"/> body is a box that
            is 20,000 units long and centered at the world space origin. - If object leave this area, they
            should be removed. A typical scenario is that an explosion shoots objects into nirvana. When
            they leave the 20,000 units area, they are removed to safe simulation time. You can adjust the
            <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> of the world body to the size of the level or the "area of 
            interest".
            </para>
            <para>
            The second function of the <see cref="F:DigitalRune.Physics.Simulation.World"/> body is to act as an anchor for 
            <see cref="T:DigitalRune.Physics.Constraints.Constraint"/>s. All constraints are two-body constraints and, for example, if you
            want to fix a rigid body at a certain position in world space you create a constraint between
            the rigid body and the world body as the other body.
            </para>
            </remarks>
        </member>
        <member name="F:DigitalRune.Physics.Simulation.World">
            <summary>
            Represents the simulation "world".
            </summary>
            <remarks>
            <para>
            This abstract rigid bodies represents the simulation world. Rigid bodies that do not touch
            this body anymore are removed from the simulation. This body can also be used if a rigid
            body should be attached with a constraint to a fixed position in the "air". In such cases 
            <see cref="F:DigitalRune.Physics.Simulation.World"/> can be used to represent the empty space. The local space of 
            <see cref="F:DigitalRune.Physics.Simulation.World"/> is equal to the world space.
            </para>
            <para>
            The default value is a <see cref="F:DigitalRune.Physics.MotionType.Static"/> rigid body with a 
            <see cref="T:DigitalRune.Geometry.Shapes.BoxShape"/> (20,000 units side length). This body is not part of the 
            <see cref="P:DigitalRune.Physics.Simulation.RigidBodies"/> collection.
            </para>
            <para>
            In general, the <see cref="P:DigitalRune.Physics.RigidBody.Shape"/> of this body can be changed. Other properties
            should not be altered. See <see cref="T:DigitalRune.Physics.Simulation"/> for more information.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.CollisionDomain">
            <summary>
            Gets the collision domain.
            </summary>
            <value>The collision domain.</value>
            <remarks>
            <para>
            This collision domain computes collisions for the rigid bodies.
            </para>
            <para>
            This collision domain can be used to make collision queries (e.g. 
            <see cref="M:DigitalRune.Geometry.Collisions.CollisionDomain.GetContacts(DigitalRune.Geometry.Collisions.CollisionObject)"/>) and it is
            allowed to add custom <see cref="T:DigitalRune.Geometry.Collisions.CollisionObject"/>s to this collision domain.
            </para>
            <para>
            The collision domain is automatically updated by the simulation. (See also 
            <see cref="P:DigitalRune.Physics.Settings.SimulationSettings.SynchronizeCollisionDomain"/>.)
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.ContactConstraints">
            <summary>
            Gets the contact constraints.
            </summary>
            <value>The contact constraints.</value>
            <remarks>
            For all bodies that have contact and where collision response is enabled, the simulation
            creates a <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> for each <see cref="T:DigitalRune.Geometry.Collisions.Contact"/>. This list is
            updated in each time step. The <see cref="T:DigitalRune.Physics.Constraints.ContactConstraint"/> instances in this collection
            should not be changed, but properties of the <see cref="P:DigitalRune.Physics.Simulation.ContactConstraints"/> can be read.
            For example, <see cref="P:DigitalRune.Physics.Constraints.ContactConstraint.LinearConstraintImpulse"/> can used to check which
            impulse was applied at this contact. This is useful if you want to "destroy" an object after
            a severe collision.
            </remarks>
        </member>
        <member name="F:DigitalRune.Physics.Simulation.ContactConstraintsInternal">
            <summary>
            Gets the contact constraints. (For internal use only.)
            </summary>
            <value>The contact constraints.</value>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.Constraints">
            <summary>
            Gets the constraints.
            </summary>
            <value>The constraints.</value>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.ConstraintSolver">
            <summary>
            Gets or sets the constraint solver.
            </summary>
            <value>The constraint solver.</value>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.ForceEffects">
            <summary>
            Gets the force effects that act on the rigid bodies.
            </summary>
            <value>The force effects.</value>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.RigidBodies">
            <summary>
            Gets the rigid bodies.
            </summary>
            <value>The rigid bodies.</value>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.ResponseFilter">
            <summary>
            Gets or sets the collision response filter.
            </summary>
            <value>
            The collision response filter. The default is <see langword="null"/>.
            </value>
            <remarks>
            Per default, this property is <see langword="null"/> which means that collision response is
            globally enabled. A filter can be set if it is necessary to disable collision response for
            certain pairs of rigid bodies. The default filter implementation is 
            <see cref="T:DigitalRune.Physics.CollisionResponseFilter"/>. The response filter should return 
            <see langword="true"/> if collision response is enabled.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.Time">
            <summary>
            Gets the current simulation time.
            </summary>
            <value>The current simulation time.</value>
            <remarks>
            <para>
            This value shows for which time the simulation state is valid. The simulation will never 
            backtrack before this time. Each <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> call usually advances this 
            time.
            </para>
            <para>
            See also <see cref="P:DigitalRune.Physics.Simulation.TargetTime"/>.
            </para>
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.TargetTime">
            <summary>
            Gets the target time to which the simulation <see cref="P:DigitalRune.Physics.Simulation.Time"/> should advance.
            </summary>
            <value>The target simulation time.</value>
            <remarks>
            <see cref="P:DigitalRune.Physics.Simulation.TargetTime"/> is the time to which the simulation should advance. 
            <see cref="P:DigitalRune.Physics.Simulation.Time"/> is the time to which the simulation has actually advanced. 
            <seealso cref="P:DigitalRune.Physics.Simulation.TargetTime"/> is updated at the beginning of <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/>. 
            Then <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> advances the simulation in fixed time steps ("sub time 
            steps"). Each step increases <see cref="P:DigitalRune.Physics.Simulation.Time"/>. <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> ends when 
            the difference between <see cref="P:DigitalRune.Physics.Simulation.TargetTime"/> and <see cref="P:DigitalRune.Physics.Simulation.Time"/> is less than one 
            fixed time step size.
            </remarks>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.TimeScaling">
            <summary>
            Gets or sets the time scaling.
            </summary>
            <value>The time scaling. The default value is <c>1.0</c>.</value>
            <remarks>
            <para>
            This is a factor which speeds up or slows down the simulation. Use a value less than 1 to
            create slow motion effects.
            </para>
            <para>
            The fixed time step size (<see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/>) is not automatically
            scaled to keep the simulation results consistent. That means, if the time scaling is set to
            2, the simulation makes twice as much steps as usual when <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> is 
            called. If the time scaling is set to 0.1 to create a slow motion effect, the simulation 
            performs only 1 / 10 of the usual simulation steps. - This standard behavior keeps the 
            simulation accuracy constant. 
            </para>
            <para>
            If constant accuracy is not required, you might want to scale
            <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/> manually with this scaling factor. Then the 
            simulation accuracy will change with the time scaling factor. Especially, when a time 
            scaling less than 1 ("slow motion") is used, it might be necessary to make the fixed time
            step smaller to keep the simulation results fluid.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="value"/> is negative.
            </exception>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.Settings">
            <summary>
            Gets or sets the simulation settings.
            </summary>
            <value>The simulation settings.</value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="E:DigitalRune.Physics.Simulation.SubTimeStepFinished">
            <summary>
            Occurs when an internal time step has finished.
            </summary>
            <remarks>
            <para>
            Depending on the size of the current time step the simulation performs a number of sub-steps 
            in <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/>. This event can be used to execute code between sub-steps.
            However, the simulations objects or settings should not be modified between sub-steps. The 
            whole simulation should be treated as read-only. The event handler should be only used to 
            monitor the simulation.
            </para>
            </remarks>
            <example>
            An event handler could be used to register collisions that happen between full time steps. 
            (Some collision only appear in sub time steps - they are not visible before or after 
            <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/>. For example, a rigid body might collide with the floor in 
            one sub time step. The collision might be resolved in the next sub time step: The rigid body 
            bounces off the floor. The event handler could check for contacts that appear between sub 
            time steps and, for example, play a sound effect. To check for collisions check the 
            <see cref="P:DigitalRune.Geometry.Collisions.CollisionDomain.ContactSets"/> in the 
            <see cref="P:DigitalRune.Physics.Simulation.CollisionDomain"/>.)
            </example>
        </member>
        <member name="P:DigitalRune.Physics.Simulation.IslandManager">
            <summary>
            Gets the <see cref="T:DigitalRune.Physics.SimulationIslandManager"/>.
            </summary>
            <value>The <see cref="T:DigitalRune.Physics.SimulationIslandManager"/>.</value>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DigitalRune.Physics.Simulation"/> class.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.OnForceEffectsChanged(System.Object,DigitalRune.Collections.CollectionChangedEventArgs{DigitalRune.Physics.ForceEffects.ForceEffect})">
            <summary>
            Called when the force effect collection was changed.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.OnRigidBodiesChanged(System.Object,DigitalRune.Collections.CollectionChangedEventArgs{DigitalRune.Physics.RigidBody})">
            <summary>
            Called when the rigid body collection was changed.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.OnConstraintsChanged(System.Object,DigitalRune.Collections.CollectionChangedEventArgs{DigitalRune.Physics.Constraints.Constraint})">
            <summary>
            Called when the constraint collection was changed.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.GetNextTimeStep(System.TimeSpan,System.TimeSpan@,System.Int32@)">
            <summary>
            Gets the size of the next simulation time step.
            </summary>
            <param name="deltaTime">The current time step size.</param>
            <param name="totalTimeStepSize">Total size of the next time step.</param>
            <param name="numberOfSubTimeSteps">The number of sub time steps.</param>
            <remarks>
            This method computes how much the next <see cref="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)"/> call will
            advance the simulation <see cref="P:DigitalRune.Physics.Simulation.Time"/> and returns the result in 
            <paramref name="totalTimeStepSize"/>. <paramref name="numberOfSubTimeSteps"/> returns
            the number of internal time steps which will be performed. Since the simulation is 
            always updated in fixed time steps, <paramref name="totalTimeStepSize"/> is
            equal to <paramref name="numberOfSubTimeSteps"/> * <see cref="P:DigitalRune.Physics.Settings.TimingSettings.FixedTimeStep"/>.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.Update(System.TimeSpan)">
            <overloads>
            <summary>
            Advances the simulation by the given time.
            </summary>
            </overloads>
            
            <summary>
            Advances the simulation by the given time.
            </summary>
            <param name="deltaTime">The size of the time step.</param>
            <remarks>
            See <see cref="T:DigitalRune.Physics.Simulation"/> for more information.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.Update(System.Single)">
            <summary>
            Advances the simulation by the given time.
            </summary>
            <param name="deltaTime">The size of the time step in seconds.</param>
            <remarks>
            See <see cref="T:DigitalRune.Physics.Simulation"/> for more information.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.RemoveBodiesOutsideWorld">
            <summary>
            Removes the bodies that have left the simulation boundaries.
            </summary>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.OnSubTimeStepFinished(System.EventArgs)">
            <summary>
            Raises the <see cref="E:DigitalRune.Physics.Simulation.SubTimeStepFinished"/> event.
            </summary>
            <param name="eventArgs">
            <see cref="T:System.EventArgs"/> object that provides the arguments for the event.
            </param>
            <remarks>
            <strong>Notes to Inheritors:</strong> When overriding <see cref="M:DigitalRune.Physics.Simulation.OnSubTimeStepFinished(System.EventArgs)"/> in 
            a derived class, be sure to call the base class's <see cref="M:DigitalRune.Physics.Simulation.OnSubTimeStepFinished(System.EventArgs)"/> method 
            so that registered delegates receive the event.
            </remarks>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.RegisterInCollisionFilter(DigitalRune.Physics.Constraints.Constraint)">
            <summary>
            Adds the specified constraint to the collision filter.
            </summary>
            <param name="constraint">The constraint to be registered.</param>
        </member>
        <member name="M:DigitalRune.Physics.Simulation.UnregisterFromCollisionFilter(DigitalRune.Physics.Constraints.Constraint)">
            <summary>
            Removes the specified constraint from the collision filter.
            </summary>
            <param name="constraint">The constraint to be removed.</param>
        </member>
    </members>
</doc>
