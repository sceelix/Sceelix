(self.webpackChunksceelix=self.webpackChunksceelix||[]).push([[986],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),h=o,f=d["".concat(p,".").concat(h)]||d[h]||c[h]||a;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4772:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return l},default:function(){return c}});var r=n(2122),o=n(9756),a=(n(7294),n(3905)),i={},s="Ports",p={unversionedId:"Graph Concepts/Ports",id:"Graph Concepts/Ports",isDocsHomePage:!1,title:"Ports",description:"This section will provide some more details about node ports and how they handle entity data.",source:"@site/docs/04-Graph Concepts/04-Ports.md",sourceDirName:"04-Graph Concepts",slug:"/Graph Concepts/Ports",permalink:"/docs/Graph Concepts/Ports",editUrl:"https://github.com/Sceelix/Sceelix/edit/master/website/docs/04-Graph Concepts/04-Ports.md",version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Entities",permalink:"/docs/Graph Concepts/Entities"},next:{title:"Flow",permalink:"/docs/Graph Concepts/Flow"}},l=[{value:"Data Dependency",id:"data-dependency",children:[]},{value:"Type Compatibility",id:"type-compatibility",children:[]},{value:"Inputs Natures",id:"inputs-natures",children:[]},{value:"Outputs and Graph Result",id:"outputs-and-graph-result",children:[]}],u={toc:l};function c(e){var t=e.components,i=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"ports"},"Ports"),(0,a.kt)("p",null,"This section will provide some more details about node ports and how they handle entity data."),(0,a.kt)("p",null,"Input and output ports are the way for nodes to pass data between each other. Most nodes receive entities in their inputs to analyse, modify, or transform them, returning them through their output ports."),(0,a.kt)("h2",{id:"data-dependency"},"Data Dependency"),(0,a.kt)("p",null,"In order for a node to execute, it needs to have entity data in all its inputs. Only then can it process all the incoming entities and produce a result."),(0,a.kt)("p",null,"Because of this logic, the nodes that have no input ports are the first to be executed. These are called ",(0,a.kt)("inlineCode",{parentName:"p"},"source")," nodes and are executed only once (per graph execution). This is because they are the ones that create or load data in the first place."),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(4471).Z})),(0,a.kt)("h2",{id:"type-compatibility"},"Type Compatibility"),(0,a.kt)("p",null,"Ports can only be connected by and edge of they are of compatible entity types. In this sense, it is important to understand well the relationships between the several input types."),(0,a.kt)("p",null,"You can connect an output of a derived type (for instance, ",(0,a.kt)("inlineCode",{parentName:"p"},"Mesh"),") to an input of a base type (for instance, ",(0,a.kt)("inlineCode",{parentName:"p"},"Entity"),"). You cannot, however, connect an input of unrelated types (for instance, ",(0,a.kt)("inlineCode",{parentName:"p"},"Mesh")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Surface"),") since a conversion is not implicitly available (you may have nodes that explicitly convert from one to another, though). You can connect from base type output to a derived type input, but verifying this can only occur when executing the graph \u2013 this is why both ports and edges will turn orange if you attempt to do this connection."),(0,a.kt)("h2",{id:"inputs-natures"},"Inputs Natures"),(0,a.kt)("p",null,"When entities arrive at an input port, they are queued, until it is that node\u2019s turn to execute. At that point, the node will execute several rounds sequentially as many times as needed until one of the input ports is depleted."),(0,a.kt)("p",null,"The nature of inputs can be classified in the way that they handle their input entities: ",(0,a.kt)("inlineCode",{parentName:"p"},"Single")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Collective"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The single input port is the most common. It takes one entity from its queue at the time to be executed at that round. It is represented by a circle shape."),(0,a.kt)("li",{parentName:"ul"},"The collective input port will take all entities from its queue at once to be executed in a single round. It is represented by a square shape.")),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(5838).Z})),(0,a.kt)("p",null,"The reason for this difference is that, since data is actually made of individual entities, some nodes need to take all entities as a whole, while other can process individual data items. For instance, a node that merges several meshes into one needs to take them all at once, after which it will output the merged mesh. However, a node that copies meshes will only take one mesh at the time, copy it, output it and then pass on to the next in line. These are effectively different cases and different processes and both are supported by Sceelix graphs."),(0,a.kt)("p",null,"It is possible for nodes to have both single and collective ports at once."),(0,a.kt)("h2",{id:"outputs-and-graph-result"},"Outputs and Graph Result"),(0,a.kt)("p",null,"Outputs are all represented by a circle shape and operate all in the same way."),(0,a.kt)("p",null,"When a graph round is finished, the resulting entities are queued at the outputs. After the node finishes its rounds, the entities are taken from the outputs and sent to the inputs that the outputs may be connected to. If the output is not connected, the entity data is added to the graph result. This means that final result of executing a graph is simply the \u201csum\u201d of all the data coming from unconnected output ports of the graph."))}c.isMDXComponent=!0},5838:function(e,t,n){"use strict";t.Z=n.p+"assets/images/portSingleCollective-51f9e8db7e2f85e2204f61da173afbc4.png"},4471:function(e,t,n){"use strict";t.Z=n.p+"assets/images/portsExecutedOrNot-4942881e3c33291666acea7c7c7624a8.png"}}]);