(self.webpackChunksceelix=self.webpackChunksceelix||[]).push([[8897],{3905:function(e,t,o){"use strict";o.d(t,{Zo:function(){return d},kt:function(){return p}});var n=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var o=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(o),p=a,m=u["".concat(l,".").concat(p)]||u[p]||h[p]||r;return o?n.createElement(m,i(i({ref:t},d),{},{components:o})):n.createElement(m,i({ref:t},d))}));function p(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=o.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=o[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}u.displayName="MDXCreateElement"},1578:function(e,t,o){"use strict";o.r(t),o.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return c},default:function(){return h}});var n=o(2122),a=o(9756),r=(o(7294),o(3905)),i={},s="Node Overview",l={unversionedId:"Nodes/NodeOverview",id:"Nodes/NodeOverview",isDocsHomePage:!1,title:"Node Overview",description:"Getting the hang of a new tool is never easy. Getting acquainted with one that requires understanding of a large list of operations is even tougher. Sceelix seems no different, yet it provides several structural features that make the learning process much easier than it seems.",source:"@site/docs/07-Nodes/NodeOverview.md",sourceDirName:"07-Nodes",slug:"/Nodes/NodeOverview",permalink:"/docs/Nodes/NodeOverview",editUrl:"https://github.com/Sceelix/Sceelix/edit/master/website/docs/07-Nodes/NodeOverview.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Parameters",permalink:"/docs/Graph Concepts/Parameters"},next:{title:"Introduction to the Unity Plugin",permalink:"/docs/Unity/Introduction"}},c=[{value:"1. Nodes represent high-level operations",id:"1-nodes-represent-high-level-operations",children:[]},{value:"2. Nodes have categories, tags and descriptions",id:"2-nodes-have-categories-tags-and-descriptions",children:[]},{value:"3. Node names have a particular structure",id:"3-node-names-have-a-particular-structure",children:[]},{value:"4. Nodes group several operations, for easy access and understanding",id:"4-nodes-group-several-operations-for-easy-access-and-understanding",children:[]},{value:"Common Naming",id:"common-naming",children:[]},{value:"Node Reference Structure",id:"node-reference-structure",children:[]}],d={toc:c};function h(e){var t=e.components,o=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"node-overview"},"Node Overview"),(0,r.kt)("p",null,"Getting the hang of a new tool is never easy. Getting acquainted with one that requires understanding of a large list of operations is even tougher. Sceelix seems no different, yet it provides several structural features that make the learning process much easier than it seems."),(0,r.kt)("p",null,"Before going deeper into each node\u2019s description, be aware or some important considerations, since they should facilitate their understanding and use:"),(0,r.kt)("h3",{id:"1-nodes-represent-high-level-operations"},"1. Nodes represent high-level operations"),(0,r.kt)("p",null,"In many node-based systems, you\u2019ll get nodes to do pretty much any kind of operations, including those for adding numbers, setting up vectors or building strings of characters. In other words, it provides a low-level control for all your tasks, which is great!\u2026 And also not so great. This means you\u2019ll probably need some solid programming knowledge to set them together, you\u2019ll sometimes need a lot of nodes to do the simplest operations, you\u2019ll need to learn a lot of nodes to get things done."),(0,r.kt)("p",null,"While Sceelix graphs do certainly allow this kind of control in theory, Sceelix actually works on a higher level, meaning that nodes are meant to do bigger and more complex operations for you, like turning a bunch of lines into meshes or setting several objects on a surface, all in one node. In other words, you need to learn fewer nodes and you\u2019ll probably have simpler and more straightforward graphs."),(0,r.kt)("p",null,"You can still build mathematical expressions on the parameters and attributes, but that will probably constitute a small part of the work, anyway."),(0,r.kt)("p",null,"Still, if you are a programming expert and would like to do some lower-level tasks, you can always do so very easily using the C# API."),(0,r.kt)("h3",{id:"2-nodes-have-categories-tags-and-descriptions"},"2. Nodes have categories, tags and descriptions"),(0,r.kt)("p",null,"When you open the node list on a graph, you can see that they are grouped in a tree-like structure. Nodes have categories, which, at this point, have been set as the main entity type that the nodes are handling. When you select an entry, you\u2019ll see that each features a small description of their function, together with a list a tags that should help identifying their exact purpose."),(0,r.kt)("h3",{id:"3-node-names-have-a-particular-structure"},"3. Node names have a particular structure"),(0,r.kt)("p",null,"In order to maintain consistency, a big effort was to name nodes after their in a consistent way. Nodes typically start by the name of the main entity type that they are handling, followed by the verb or noun that indicates what they are doing on this entity. \u201cActor Group\u201d means that a grouping operation is performed on actor entities, \u201cMesh Create\u201d creates meshes and \u201cSurface Modify\u201d modifies has operations that somehow change surfaces."),(0,r.kt)("p",null,"There are some nodes that do not follow this naming, and that\u2019s because they operate on all and any kinds of entities (\u201cCopy\u201d, \u201cLog\u201d, \u201cProperty\u201d\u2026), so including the \u201cEntity\u201d before was redundant."),(0,r.kt)("h3",{id:"4-nodes-group-several-operations-for-easy-access-and-understanding"},"4. Nodes group several operations, for easy access and understanding"),(0,r.kt)("p",null,"One thing to note is that nodes typically aggregate several operations, meaning that a node such as the \u201cMesh Create\u201d can actually create many different kinds of meshes, which you can choose from a list. Each choice presents new suboptions and, in turn, each suboption can encompass new ones. There are several reasons for this approach. One the one hand, this reduces the amount of different nodes, which makes the whole range of possibilities much less overwhelming. On the other hand, it allows for easy switch between choices (for example, for replacing a cube with a sphere) while making use of parameters that are common."),(0,r.kt)("p",null,"Since in theory this could be used to form one big node that would aggregate all the operations, that there should be a balance, or else nodes could become very complex. This is also why some nodes with growing numbers of operations have been \u201cunfolded\u201d into new independent nodes."),(0,r.kt)("h2",{id:"common-naming"},"Common Naming"),(0,r.kt)("p",null,"Despite the fact that every entity type has its on set of specific operations, there are many that are similar in nature, so they follow the same naming pattern, too. Here is a description of some common operations that are applicable to several entities:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Create:")," Creates new entities from scratch, based on a pattern, a known geometrical model, randomness, or even by influence/transformation of another entity. \u201cMesh Create\u201d, for instance, can create cubes, spheres, cones, but also create polygons from converting paths, too."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Load:")," Loads entities from some kind of source format, like a file, folder, database, etc.  For example, \u201cSurface Load\u201d loads image files, \u201cMesh Load\u201d loads fbx, dae or obj files, for instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Modify:")," Performs some kind of modification on the entity and the entity alone (no extra inputs). One entities comes in, another comes out at a time. Does not create or divide entities into more. Just a simple internal modification of the entity. For instance, \u201cSurface Modify\u201d including smoothing, resolution change or normal recalculation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Subselect:")," Allows a part of an entity to be extracted/separated from the original entity, according to a certain condition. For example, \u201cMesh Subselect\u201d allows faces to be extracted based on certain properties, so that it can be handled differently."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Divide:")," Similar to the subselect, but does actually divides the original entity into many entities, according to certain criteria. The \u201cMesh Divide\u201d can divide meshes into groups of faces that share a certain size or vertex count, for instance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Decompose:")," Not to be confused with previous one. Decomposing an object allows us to access its subparts, but without actually destroying their connections, like the division would do. This allows, for example in the \u201cPath Decompose\u201d, one to access the vertices of a path without breaking their edge links. This is very useful if you want to simply set attributes to the individual parts of an entity (set different colors to its vertices, number the edges, etc.)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Merge:")," The opposite of the \u201cDivide\u201d, as it allows entities of the same type to be joined into one. For example, the \u201cPath Merge\u201d joins different sets of edges, yet does not force vertices to be shared."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Unify:")," Often used together with the \u201cMerge\u201d, it forces, for example, vertices that lie on the same position to be joined into one, so as to enforce connectivity inside meshes faces or path edges."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Save:")," The opposite of the Load\u201d, as the name suggests. Saves entities to a file, folder, database, etc. \u201cMesh Save\u201d, for instance, allows meshes to be saved to an obj or fbx file format.")),(0,r.kt)("h2",{id:"node-reference-structure"},"Node Reference Structure"),(0,r.kt)("p",null,"Because each node aggregates several different operations, their documentation is also structured in a particular way."),(0,r.kt)("p",null,"As mentioned before, nodes can have inputs, outputs and parameters. Parameters can have subparameters, some of which can be enumerated in lists or chosen from a limited set of options. Some inputs and outputs exist on the nodes, regardless of their configuration. However, some parameter value choices does indeed affect the number or type or inputs and outputs. For example, the \u201cMesh Subselect\u201d creates a new output, which is the one through which the extracted mesh part will come though. The \u201cGame Entity Create\u201d node, on the other hand, can toggle the option to provide an input port to accept a mesh from which the game entity should be created."),(0,r.kt)("p",null,"In sum, there are a lot of possible options, hence each node documentation is structured as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Image:")," The typical look of the node when it is added to the graph (yet might change according to the parameter configuration)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Description:")," A description of what the node does."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Parameter tree:")," The enumeration of parameters of the node. Since parameters may have subparameters, these are organized in a tree-like structure whose leaves can be expanded or collapsed. Parameters that introduce new inputs or outputs are so identified, featuring a link to either one of the two sections."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Input list:")," The list of inputs of the node, which can be empty. It features a subsection \u2013 parameter inputs \u2013 which features those ports that depend on certain parameter choices."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Output list:")," The list of outputs of the node, which can be empty. It features a subsection \u2013 parameter outputs \u2013 which features those ports that depend on certain parameter choices.")))}h.isMDXComponent=!0}}]);